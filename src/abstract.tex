\begin{otherlanguage}{magyar}

\paragraph*{Kivonat}
\phantomsection
\addcontentsline{toc}{chapter}{Kivonat}
\thispagestyle{plain}

Összetett szoftverek fejlesztése során a kódbázis növekedésével általában a kódban megjelenő fejlesztői hibák száma is nő. Ezen hibák fokozott kockázatot jelenthetnek, hiszen az esetlegesen helytelen, nemkívánatos működés mellett jelentős biztonsági réseket eredményezhetnek. Kiaknázásuk által rosszindulatú támadók a szoftvert számukra kedvező, az eredetileg tervezettől eltérő módon futtathatják.

A statikus forráskódanalízis egy, az iparban gyakran használt, általánosan elfogadott szoftvertesztelési megközelítés. Célja, hogy minél több szoftverfejlesztői hibát minél előbb, még a program fejlesztési szakaszában – a kód lefordítása és lefuttatása nélkül – tárjon fel, csökkentve ezzel a működés közben felmerülő programhibák számát, és így a telepítés utáni hibajavítással járó pluszköltségeket. Felhasználási lehetőségei közé tartozik a csoportos, vállalati kódolási szabályoknak, stílusoknak való megfelelés ellenőrzése, illetve egyre több statikus analízis eszköz nyújt támogatást egyre komolyabb logikai hibák fordítási vagy akár kódírási idejű feltárásához is.

Napjaink folytonos integrációs infrastruktúrájába illesztve a statikus analízis hatékony eszköz lehet a fejlesztői hibák feltárásában, és ezáltal az állandó kódminőség biztosításában. Nagymértékű népszerűsége ellenére a JavaScript nyelvhez – annak dinamikus és gyenge típusosságából eredő sajátosságok következményeként – kevés statikus analízis-eszköztár létezik, és a rendelkezésre álló eszközök sem nyújtanak teljeskörű megoldást nagyméretű, vállalati szintű JavaScript forráskódtárak összefüggő elemzéséhez. Gyakran felmerülő probléma emellett az analitikus komplexitással általában fordítottan arányos sebesség: sem folytonos integrációs infrastruktúrába, sem fejlesztőkörnyezetbe nem illeszthető olyan eszköz, amely miatt a fordítási idő akár órákkal növekszik.

Dolgozatomban egy már létező, a fenti követelményeknek nagy részben eleget tevő statikus kódanalízis-keretrendszer bővítését tervezem meg, fejlesztem ki és értékelem. A bővítés során egyrészt új – logikai és formai – JavaScript-alapú statikus analízis-kikötéseket implementálok a rendszerhez. Másrészt lehetővé teszem, hogy a rendszer több összefüggő JavaScript-modulon (forrásfájlon) átívelő, globális analízis-kikötések kiértékelésére is képes legyen. Ezt kihasználva újabb kikötéseket implementálok, immáron több JavaScript-modult összefüggően elemző analízisekhez.

\end{otherlanguage}

\clearpage

\paragraph*{Abstract}
\phantomsection
\addcontentsline{toc}{chapter}{Abstract}
\thispagestyle{plain}

In complex software development, the number of developer errors usually increases with the growth of the code base. These errors can be sufficiently dangerous: besides causing improper or undesirable operation, they can lead to serious security vulnerabilities. By exploiting them, malicious attackers can take control over the software in some ways to run it according to their goals, or at least differently than originally intended.

Static source code analysis is a widely used, generally approved software testing approach. Its goal is to discover as many human errors as possible, as early as possible — meaning during development, without compiling and running the code —, in order to reduce the number of software failures in production, and to minimize the extra costs of fixing bugs after deployment. Possible applications of static analysis include verifying whether the code complies with enterprise coding standards and styles, but more and more analysis toolsets provide ways to detect more complex logical errors during compilation time, or even development time.

In our days, static analysis toolsets integrated into Continous Integration (CI) workflows can be an efficient way to detect developer errors at commit- and build-time, and thus to provide constant code quality. Despite its widespread popularity, the JavaScript language does not have extensive static analysis tooling — a possible cause can be the language's dynamic and weak typing —, and the available tools do not provide a full-scale solution to coherently analyse large, enterprise-grade code repositories either. Moreover, increased analysis complexity generally means significant reduction of speed, and of course a tool can not be integrated neither into a CI workflow, nor into a development environment, if it increases the build time with even several hours.

In this thesis I design, implement and evaluate the extension of an existing static code analysis framework complying with most of the above detailed requirements. With the extension on the one hand, I implement new JavaScript static analysis constraints — logical and formal — for the framework. On the other hand, I extend the system with the capability of analysing more than one JavaScript source code files coherently, thus I provide a way to evaluate global analysis queries over more than one JavaScript modules related to each other. Then I implement more analysis constraints, but now for coherently analysing more than one, related JavaScript modules.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
