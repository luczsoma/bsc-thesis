\chapter{Elaboration of the Workflow}
\label{chapter:elaboration}

This chapter details the implementation of the analyses and the additional proceedings about analysing more than one \es modules coherently. Thus, this chapter encompasses all \emph{semantic} changes of the framework.

Following Dániel Stein~\cite{stein-daniel-msc} and \Cref{chapter:overview} of this thesis, a full analysis procedure of the Codemodel-Rifle framework can be broken down to three distinct phases:

\begin{enumerate}
\item \textsc{\textbf{Import:}} Every \es source file (containing the source code of one \es module) of the analysed code repository is imported into Codemodel-Rifle. The modules are translated to Abstract Semantic Graph models. The ASGs are stored as distinct, per-module property graphs in the underlying Neo4j graph database.
\item \textsc{\textbf{Interconnect:}} The related modules' separate graphs are interconnected along the \emph{export} and \emph{import} semantics of \es. This makes possible to evaluate analyses over more than one modules coherently.
\item \textsc{\textbf{Analyse:}} The predefined analyses are executed.
	\begin{enumerate}
	\item The graph manipulations of the \emph{Qualifier System} are performed.
	\item The defect patterns are matched.
	\end{enumerate}
\end{enumerate}

Since I have not made any semantic changes to the \textsc{Import} phase, this chapter focuses to the \textsc{Interconnect} and the \textsc{Analyse} phases.


\section{Interconnecting Related \es Modules}
\label{section:interconnect}

This section describes the work I made to support analysing more than one \es modules coherently. The approach follows~\cite{stein-daniel-msc}, and completes it by developing the semantics of missing use cases, and then implementing them. To shorty summarise: in order to coherently analyse several related \es modules with the Codemodel-Rifle framework, the related modules' separate property graphs are interconnected by well-defined rules. As previously already mentioned, these rules are built upon the \emph{export} and \emph{import} semantics of \es~\cite{exploringes6}. Equivalently, \es modules are considered to be \emph{related}, if they refer to each other by using \emph{export} and \emph{import} statements.


\subsection{The \es Module System}

As the language gained traction, JavaScript projects rapidly grown to a size where modularisation became critical in order to keep the code logically organised. Today's largest \es code bases include Google's Gmail\footnote{\texttt{https://www.gmail.com}} with approx. 400,000 lines of code~\cite{gmail-loc}, Ruben Daniels' Cloud9 IDE\footnote{\texttt{https://c9.io}} with approx. 300,000 lines of code~\cite{cloud9-loc}, and Lucidchart\footnote{\texttt{https://www.lucidchart.com}} with approx. 200,000 lines of code~\cite{lucidchart-loc}. The product of Tresorit featured in this thesis consists of approx. 35,000 lines of \es code.

Plain JavaScript does not have built-in support for modules~\cite{exploringes6}, there are only community-provided solutions like \emph{RequireJS}\footnote{\texttt{http://requirejs.org}}. In contrary, the 6\textsuperscript{th} version of \es has language-level support for modules: each source file represents exactly one module. Entities like variables and functions defined in one module, or even complete modules themselves can be \emph{exported} to be \emph{imported} to a different module. By default, modules are referred by their relative pathname, without the containing file's extension. Entities that are not explicitly exported remain \emph{private}, meaning they can not be imported to other modules.

In \es 6, there are several ways of exporting and importing entities~\cite{exploringes6}, these are detailed in the next subsections. The Codemodel-Rifle framework had only minimal demonstrative support for interconnecting several \es modules; I extended Dániel Stein's work by covering the most used \emph{export-import case combinations}.


\subsection{Export Syntaxes and Cases}

By default, each entity can only be accessed in the scope of the module it was declared in. To be accessed in other modules, the entity has to be explicitly exported first. \Cref{fig:export-syntaxes} presents export syntax examples of \es 6, based on~\cite{export-syntaxes}. Since these statements can be almost arbitrarily combined, and the number of exported variables is not limited in theory, the list of differing export syntaxes of \es 6 is practically endless.

Therefore, \emph{export syntaxes} need to be distinguished from \emph{export cases}. An \emph{export case} is identified by the \emph{basic form} of an \emph{export syntax}. An \emph{export syntax} written in \emph{basic form} does not combine divers syntaxes, and exports only one entity per export statement. \Cref{fig:export-syntaxes} displays all syntaxes in \emph{basic form}, thus it lists all members of the \emph{distinct export cases'} finite set. Each different \emph{export case} has a unique graph pattern in the ASG.

\begin{figure}[!p]
	\centering
	\begin{lstlisting}[language=JavaScript]
			// exportName
			export { name1, ... };
			// exportDefaultName
			export default name1;
			// exportAlias
			export { name1 as exportedName1, ... };
			// exportAsDefault
			export { name1 as default, ... };
			// exportEmptyLetDeclaration
			export let name1, ... ;
			// exportEmptyVarDeclaration
			export var name1, ... ;
			// exportLetDeclaration
			export let name1 = ..., ... ;
			// exportVarDeclaration
			export var name1 = ..., ... ;
			// exportConstDeclaration
			export const name1 = ..., ... ;
			// exportClass
			export class name1 { ... }
			// exportFunction
			export function name1(...) { ... }
			// exportGenerator
			export function* name1(...) { ... }
			// exportDefaultClass
			export default class name1 { ... }
			// exportDefaultFunction
			export default function name1(...) { ... }
			// exportDefaultGenerator
			export default function* name1(...) { ... }
			// exportDefaultExpression
			export default expression;
			// exportDefaultAnonymousClass
			export default class { ... }
			// exportDefaultAnonymousFunction
			export default function (...) { ... }
			// exportDefaultAnonymousGenerator
			export default function* (...) { ... }
			// exportExpression
			export expression;
			// reexportNamespace
			export * from ...;
			// reexportName
			export { name1, ... } from ... ;
			// reexportAlias
			export { import1 as importedName1, ... } from ...;
	\end{lstlisting}
  \caption{Export syntax examples of \es 6}
  \label{fig:export-syntaxes}
\end{figure}


\subsection{Import Syntaxes and Cases}

An entity declared in module \textbf{A} can be accessed in module \textbf{B}, if \textbf{A} exports, and \textbf{B} imports the entity. All exported entities of a module can be imported as well: in this case an object is created with the name of the imported module's alias, and with members listing the exported entities of the imported module. \Cref{fig:import-syntaxes} present import syntax examples of \es 6, based on~\cite{import-syntaxes}. Like the exports, these statements can also be combined with each other, making the list of the possible import syntax combinations endless.

Thus, \emph{import syntaxes} need to be distinguished from \emph{import cases}, similarly to the exports. An \emph{import case} is identified by the \emph{basic form} of an \emph{import syntax}. \Cref{fig:import-syntaxes} displays all syntaxes in \emph{basic form}. Each different \emph{import case} has a unique graph pattern in the ASG.

\begin{figure}[!htb]
	\begin{lstlisting}[language=JavaScript]
		// importName
		import { name1, ... } from "exporter";
		// importAlias
		import { name1 as importedName1, ... } from "exporter";
		// importDefault
		import defaultName from "exporter";
		// importNamespace
		import * as exportedModule from "exporter";
		// importModule
		import "exporter";
	\end{lstlisting}
  \caption{Import syntax examples of \es 6}
  \label{fig:import-syntaxes}
\end{figure}


\subsection{Number of Export-Import Combinations}

Let $\mathbb{E}$ be set of all the distinct export cases, and let $\mathbb{I}$ be the set of all the distinct import cases. As \Cref{fig:export-syntaxes} and \Cref{fig:import-syntaxes} show, $|\mathbb{E}| = 23$, and $|\mathbb{I}| = 5$. If all export cases would be compatible with all import cases according to the \es grammar, set $\mathbb{C}$ containing all combinations would be $\mathbb{C} = \mathbb{E} \times \mathbb{I}$ with the cardinality of $|\mathbb{C}| = |\mathbb{E}| * |\mathbb{I}| = 23 * 5 = 115$.

\begin{figure}[!htb]
	\begin{lstlisting}[language=JavaScript]
					// exporter.js
					export let name1 = ...;
					// importer.js
					import defaultName from "exporter";
	\end{lstlisting}
  \caption{An example of incompatible export-import cases}
  \label{fig:incompatible-export-import-example}
\end{figure}

Let $\mathbb{S}$ be the set of the export-import combinations supported by Codemodel-Rifle, and let $\alpha$ be the number of distinct algorithms needed to be implemented for supporting every element of $\mathbb{S}$. The following applies: $\alpha \leq |\mathbb{S}|$, since the framework needs one separate algorithm for each export-import case at most. Since not all export cases are compatible with all import cases (a counterexample is displayed on \Cref{fig:incompatible-export-import-example}), the set of \emph{semantically valid} export-import combinations is narrower than $\mathbb{C}$. Codemodel-Rifle should interconnect only semantically valid export-import cases, so $\mathbb{S} \subset \mathbb{C}$. Also, $\alpha$ can be reduced further by involving ASG-specific knowledge: with graph pattern generalisation techniques, several export cases can be handled as one at implementing the interconnections, while preserving semantics. Therefore several export cases can be covered by one algorithm, so $\alpha < |\mathbb{S}|$. In addition, by choosing particular export and import cases not to be supported by Codemodel-Rifle, $\alpha$ can be lowered even further. Case compatibility, unsupported cases and pattern generalisation techniques are detailed in the following subsections.


\subsection{Compatibility of the Export-Import Cases}

An export-import combination is considered to be \emph{semantically valid}, if it complies with the \es grammar~\cite{export-grammar, import-grammar}. Accordingly, semantically valid export-import combinations consist of \emph{compatible} export-import cases: export case \textbf{E} and import case \textbf{I} are considered to be \emph{compatible} with each other, if the entity exported by \textbf{E} can be imported by \textbf{I}, following the \es grammar. \Cref{fig:incompatible-export-import-example} shows an example of incompatible export-import cases. \Cref{table:export-import-compatibility} displays a compatibility matrix for \es export-import cases.

As only semantically valid export-import combinations are required to be supported by Codemodel-Rifle to evaluate analyses over several \es modules coherently, incompatible cases do not need to be covered. This reduces $\alpha$ from $115$ to $84$ (see \Cref{table:export-import-compatibility}).


\subsection{Unsupported Cases}

There are export and import cases which I chosen not be supported by Codemodel-Rifle because of implementation difficulties, or the cases' irrelevant usage. This reduces $\alpha$ from $84$ to $33$. The unsupported export and import cases are the following:

\begin{itemize}
\item \textbf{\lstinline{exportDefaultExpression, exportDefaultAnonymousClass, export\- DefaultAnonymousFunction, exportDefaultAnonymousGenerator}}: There is no clear way for interconnecting the exported entities with the importer module.
\item \textbf{\lstinline{exportExpression}}: Unnamed expressions (e.g.\ \lstinline[language=JavaScript]{export 1 + 2;}) can not be imported, because they can not be referenced.
\item \textbf{\lstinline{reexportName},} \textbf{\lstinline{reexportAlias},} \textbf{\lstinline{reexportNamespace}}: According to my experiences, re-exporting is used very little.
\item \textbf{\lstinline{importNamespace}}: There is no clear solution for including all exported variable of the imported module as an object into the ASG.
\item \textbf{\lstinline{importModule}}: It only loads the module, does not import anything. The first such import in a program executes the body of the module~\cite{exploringes6}.
\end{itemize}

\Cref{table:export-import-compatibility} displays unsupported export and import cases with a grey background. With excluding the incompatible and the unsupported cases from the interconnection process, $\alpha$ is reduced by more than $71\%$, from $115$ to $33$. This saves a significant amount of work without notable loss of the analyses' credibility — unsupported cases were mostly chosen because of their unpopularity. Nevertheless, these cases need to be covered later as well.

\begin{table}[!htb]
	\newcommand{\yep}{\tikz\draw[black,fill=black] (0,0) circle (0.8ex);\xspace}
	\newcommand{\nop}{\tikz\draw[black,fill=none] (0,0) circle (0.8ex);\xspace}

	\definecolor{grey}{gray}{0.85}
	\newcolumntype{g}{>{\columncolor{grey}}c}

	\small
	\centering
	\begin{tabular}{l|cccgg}
		\hline
																				& \rotatebox{90}{importName}
																				& \rotatebox{90}{importAlias}
																				& \rotatebox{90}{importDefault}
																				& \rotatebox{90}{importNamespace~~}
																				& \rotatebox{90}{importModule}
																				\\
		\hline
		{exportName}												& \yep & \yep & \nop & \yep & \yep \\
		{exportDefaultName}									& \yep & \yep & \yep & \yep & \yep \\
		{exportAlias}												& \yep & \yep & \nop & \yep & \yep \\
		{exportAsDefault}										& \nop & \nop & \yep & \nop & \yep \\
		{exportEmptyLetDeclaration}					& \yep & \yep & \nop & \yep & \yep \\
		{exportEmptyVarDeclaration}					& \yep & \yep & \nop & \yep & \yep \\
		{exportLetDeclaration}							& \yep & \yep & \nop & \yep & \yep \\
		{exportVarDeclaration}							& \yep & \yep & \nop & \yep & \yep \\
		{exportConstDeclaration}						& \yep & \yep & \nop & \yep & \yep \\
		{exportClass}												& \yep & \yep & \nop & \yep & \yep \\
		{exportFunction}										& \yep & \yep & \nop & \yep & \yep \\
		{exportGenerator}										& \yep & \yep & \nop & \yep & \yep \\
		{exportDefaultClass}								& \yep & \yep & \yep & \yep & \yep \\
		{exportDefaultFunction}							& \yep & \yep & \yep & \yep & \yep \\
		{exportDefaultGenerator}						& \yep & \yep & \yep & \yep & \yep \\
		\rowcolor{grey}
		{exportDefaultExpression}						& \nop & \nop & \yep & \nop & \yep \\
		\rowcolor{grey}
		{exportDefaultAnonymousClass}				& \nop & \nop & \yep & \nop & \yep \\
		\rowcolor{grey}
		{exportDefaultAnonymousFunction}		& \nop & \nop & \yep & \nop & \yep \\
		\rowcolor{grey}
		{exportDefaultAnonymousGenerator}		& \nop & \nop & \yep & \nop & \yep \\
		\rowcolor{grey}
		{exportExpression}									& \nop & \nop & \nop & \nop & \yep \\
		\rowcolor{grey}
		{reexportName}											& \yep & \yep & \nop & \yep & \yep \\
		\rowcolor{grey}
		{reexportAlias}											& \yep & \yep & \nop & \yep & \yep \\
		\rowcolor{grey}
		{reexportNamespace}									& \yep & \yep & \yep & \yep & \yep \\
		\hline
	\end{tabular}

	\caption{Export-import compatibility matrix with unsupported cases in grey}
	\label{table:export-import-compatibility}
\end{table}


\subsection{Pattern Generalisation Techniques}

After excluding the incompatible and the unsupported cases, $33$ different import-export combinations still need to be covered by the interconnection process. This would imply that $\alpha = 33$ algorithms are needed for all combinations, but $\alpha$ can be reduced further by involving ASG-specific knowledge. At interconnecting modules, several export cases' graph patterns can be matched by one, somehow generalised pattern description, and thus several export cases can be interconnected with the same algorithm. For import cases, generalisation is neither possible nor necessary, since only three, semantically different import cases are supported by Codemodel-Rifle. To proceed, two concepts are defined.

\paragraph{Semantically correct interconnection}

An export-import interconnection between two modules' property graphs is \emph{semantically correct} to Codemodel-Rifle, if the interconnection is reversible, it correlates with the semantics of \es, and the interconnected property graphs contain the same information as the separate property graphs.

\paragraph{Isomorphic export case}

Two export cases are \emph{isomorphic}, if they contain ASG patterns which can be interconnected to an import case along the same nodes and edges, applying the same algorithm, and the interconnection is semantically correct.

Applying the two definitions, my workflow was the following for finding the isomorphic export cases in order to reduce $\alpha$:

\begin{enumerate}
\item I inspected the similarly looking export cases' ASG patterns, whether they can be described by one, somehow generalised graph pattern description.
\item If yes, I examined if the two export cases can be interconnected with import cases along the same nodes and edges, with the same algorithm.
\item If yes, I performed the interconnections, and inspected them whether they are semantically correct.
\item If yes, the two export cases are isomorphic.
\end{enumerate}

\Cref{fig:export-declaration-demonstration} presents two distinct ASGs of two isomorphic export cases as an example. These two cases are described below with also specifying their location on the figure:
\begin{itemize}
\item \textsc{on the left:}\enskip\lstinline[language=JavaScript]{export let name1 = "name1Value"}
\item \textsc{on the right:}\enskip\lstinline[language=JavaScript]{export function name1()}\texttt{ \{ }\lstinline{return "name1Value";}\texttt{ \}}
\end{itemize}

The two export cases are isomorphic because of the following.
\begin{enumerate}[label=\alph*)]
\item \emph{The two graphs contain patterns which can be matched by one pattern description.} Even though these patterns (indicated with thicker outlines) contain nodes and edges with different labels and properties, in Neo4j it is possible to match both of them with only one Cypher expression.
\item \emph{Both patterns can be interconnected to an import along the same nodes and edges applying the same algorithm.} Applying the semantics of Codemodel-Rifle developed along practical reasons, only the node labeled as \lstinline{Declaration} (indicated with blue filling) needs to be connected to the import module's ASG in both cases.
\item \emph{The interconnection is semantically correct.} In both cases, the interconnection is reversible, and no information is lost. The interconnection also correlates with the semantics of \es: in both cases, it expresses that a \emph{named declaration} has been imported from another module. For the aim of the Codemodel-Rifle framework — which is revealing possible errors in software by static analysis — this is a satisfactory way of implementing the interconnections.
\end{enumerate}

\begin{figure}[!htb]
	\centerfloat
	\includegraphics[width=\textwidth+3cm, trim=12mm 12mm 12mm 12mm,clip]{figures/export-declaration-demonstration.pdf}
	\caption{Two isomorphic export cases contain the same pattern}
	\label{fig:export-declaration-demonstration}
\end{figure}

The process of pattern generalisation needs to be performed carefully. The generalised patterns must match only those export cases' patterns that can be interconnected with imports in a semantically correct way. If the patterns are too broadly generalised, they will match more export cases than intended, resulting semantically incorrect interconnections (between incompatible export-import cases). In contrary, if they are too narrowly specified, they will match only one export case, resulting no reduction of the $\alpha$.

In the following, I list all export cases I found to be isomorphic in groups. Each group's name implies why the elements are isomorphic in the group. Since every element can be interconnected with imports using the same algorithm per group, an isomorphic group with its elements can be considered as one generalised export case regarding the ASG interconnection process of the Codemodel-Rifle framework. The following $5$ isomorphic export groups have been formed:

\begin{itemize}
\item \textbf{\lstinline{exportName}}
	\begin{itemize}
	\item \lstinline{exportName}
	\end{itemize}

\item \textbf{\lstinline{exportDefaultName}}
	\begin{itemize}
	\item \lstinline{exportDefaultName}
	\end{itemize}

\item \textbf{\lstinline{exportAlias}}
	\begin{itemize}
	\item \lstinline{exportAlias}
	\item \lstinline{exportAsDefault}
	\end{itemize}

\item \textbf{\lstinline{exportDeclaration}}
	\begin{itemize}
	\item \lstinline{exportEmptyLetDeclaration}
	\item \lstinline{exportEmptyVarDeclaration}
	\item \lstinline{exportLetDeclaration}
	\item \lstinline{exportVarDeclaration}
	\item \lstinline{exportConstDeclaration}
	\item \lstinline{exportClass}
	\item \lstinline{exportFunction}
	\item \lstinline{exportGenerator}
	\end{itemize}

\item \textbf{\lstinline{exportDefaultDeclaration}}
	\begin{itemize}
	\item \lstinline{exportDefaultClass}
	\item \lstinline{exportDefaultFunction}
	\item \lstinline{exportDefaultGenerator}
	\end{itemize}
\end{itemize}

Based on the above, having $5$ isomorphic export groups means that the number of distinctly handled export cases has been reduced to $5$. \Cref{table:updated-compatibility-table} shows the updated compatibility table with export cases grouped by their isomorphism, without listing the unsupported cases. By this time, with excluding incompatible and unsupported cases and applying pattern generalisation techniques, $\alpha$ has been reduced to $13$, meaning only $13$ separate algorithms have to be implemented in order to cover most of the export-import cases.

\begin{table}[!htb]
	\newcommand{\yep}{\tikz\draw[black,fill=black] (0,0) circle (0.8ex);\xspace}
	\newcommand{\nop}{\tikz\draw[black,fill=none] (0,0) circle (0.8ex);\xspace}

	\centering
	\small
	\begin{tabular}{l|ccc}
		\hline
																& \rotatebox{90}{importName}
																& \rotatebox{90}{importAlias}
																& \rotatebox{90}{importDefault~~}
																\\
		\hline
		exportName									& \yep & \yep & \nop \\
		exportDefaultName						& \yep & \yep & \yep \\
		exportAlias									& \yep & \yep & \yep \\
		exportDeclaration						& \yep & \yep & \nop \\
		exportDefaultDeclaration		& \yep & \yep & \yep \\
		\hline
	\end{tabular}

	\caption{Export-import compatibility matrix with exports grouped by their isomorphism}
	\label{table:updated-compatibility-table}
\end{table}


\subsection{Implementing the Interconnection Algorithms}

After thoroughly inspecting the ASG signatures of the numerous export and import cases for minimising the number of algorithms to be implemented, actually implementing the algorithms was straightforward. In this section, I will not present all combinations in detail. Instead, I describe the general steps of the interconnection process, and I provide a complete example with one concrete combination. In the Appendix, all export-import case combinations are listed with their interconnection algorithms.

The steps of the interconnection process in general can be described as follows:

\begin{enumerate}
\item Match each to-be-exported entities of the exporter module with strictly unique patterns containing all necessary identifiers and information for the export.
\item Match each to-be-imported entities of the importer module with strictly unique patterns containing all necessary identifiers and information for the import.
\item Perform interconnections between the exporter module and the importer module by finding corresponding entities in the two modules based on identifiers like names and/or default export/import bindings.
\item Clean the graph, so it will not contain duplicate nodes or edges after the interconnection process.
\end{enumerate}

\vspace*{-3mm}
\begin{figure}[!htb]
	\begin{lstlisting}[language=JavaScript]
			// exporter.js
			let name1 = "name1Value";
			export { name1 };

			// importer.js
			import { name1 as importedName1 } from "exporter";
	\end{lstlisting}
  \caption{Modules for demonstrating the \emph{exportName–importAlias} combination}
  \label{fig:export-import-example-source}
\end{figure}

I chose the fully detailed combination to be the \emph{exportName–importAlias}. The \emph{exportName} case is in the \lstinline{exporter} module, the \emph{importAlias} case is in the \lstinline{importer} module. \Cref{fig:export-import-example-source} shows the source code of the two modules.

\Cref{fig:export-import-example-asg} displays the process of interconnecting the \lstinline{exporter} module's graph with the \lstinline{importer} module's graph along the \emph{exportName–importAlias} case combination. The following steps are performed on the ASGs of the modules:
\begin{enumerate}
\item Find the exported \lstinline{Variable} with its \lstinline{Declaration} in the \lstinline{exporter} module marked with blue colour. The full matched pattern is indicated with thicker outlines.
\item Find the imported \lstinline{Variable} with its \lstinline{BindingIdentifier} and its \lstinline{Declaration} in the \lstinline{importer} module marked with crimson colour. The full matched pattern is indicated with thicker outlines.
\item Check if the \lstinline{Import} node's \lstinline{moduleSpecifier} attribute is equal to the exporter module's name, which is currently \lstinline{exporter}.
\item Check if the \lstinline{name} attribute of the \lstinline{IdentifierExpression} node (connecting to the \lstinline{ExportLocalSpecifier} node) is equal to the \lstinline{ImportSpecifier} node's \lstinline{name} attribute. In this particular \emph{importAlias} case, checking \lstinline{ImportSpecifier} node's \lstinline{name} attribute instead of the imported \lstinline{Variable} node's \lstinline{name} attribute provides the support for the \emph{aliased} import.
\item Create a \lstinline{declarations} edge from the imported \lstinline{Variable} node to the exported \lstinline{Declaration}. This is indicated with a thick black outline.
\item Create a \lstinline{node} edge from the exported \lstinline{Declaration} node to the imported variable's \lstinline{BindingIdentifier} node. This is indicated with a thick black outline.
\item Delete the original \lstinline{Declaration} node of the imported variable with its edges.\footnote{This step does not cause loss of information: the graph still contains the information that the variable was \emph{imported}.} These are indicated with dashed outlines.
\end{enumerate}

These steps are translated to Cypher, and sent to the database. Each export-import combination featured in \Cref{table:updated-compatibility-table} has a separate Cypher query. As these \emph{export-import interconnection queries} are \emph{independent} from each other — they do not modify the others' results in any way — they can be executed in any order. The queries are also \emph{idempotent}: they can be re-executed arbitrarily many times without different outcomes on the same dataset.

\Cref{fig:export-import-example-cypher-source} presents the full Cypher query of the \emph{exportName–importAlias} combination. The query contains a node with a label that is not displayed in the visualised graph: \lstinline{CompilationUnit}. At translating the modules into ASGs, Codemodel-Rifle creates a node with the label \lstinline{CompilationUnit} for each distinct source file. Each module's all graph nodes are connected to the module's \lstinline{CompilationUnit} node. The node also stores information about the parsed module's file path. As displaying the \lstinline{CompilationUnit} nodes with all their connections would make the graph very dense, they are omitted.

\newpage
\vspace*{5em}
\begin{figure}[!h]
	\centerfloat
	\includegraphics[width=\textwidth+4cm, trim=12mm 12mm 12mm 12mm,clip]{figures/export-import-example-asg.pdf}
	\caption{Interconnecting the \lstinline{exporter} module with the \lstinline{importer} module in the export-import combination \emph{exportName–importAlias}}
	\label{fig:export-import-example-asg}
\end{figure}

\newpage
\vspace*{8.35em}
\begin{figure}[!h]
	\begin{lstlisting}[language=Cypher]
MATCH
// exporter.js: let name1 = "name1Value"; export { name1 };
    (exporter:CompilationUnit)-[:contains]->(:ExportLocals)
        -[:namedExports]->(:ExportLocalSpecifier)
        -[:name]->(exportBindingIdentifier:IdentifierExpression)
        <-[:node]-(:Reference)
        <-[:references]-(:Variable)
        -[:declarations]->(declarationToMerge:Declaration)
        -[:node]->(:BindingIdentifier),

// importer.js: import { name1 as importedName1 } from "exporter";
    (importer:CompilationUnit)-[:contains]->(import:Import)
        -[:namedImports]->(importSpecifier:ImportSpecifier)
        -[:binding]->(importBindingIdentifierToMerge:BindingIdentifier)
        <-[:node]-(declarationToDelete:Declaration)
        <-[:declarations]-(importedVariable:Variable)

    WHERE
    exporter.parsedFilePath CONTAINS import.moduleSpecifier
    AND exportBindingIdentifier.name = importSpecifier.name

MERGE
    (importedVariable)-[:declarations]->(declarationToMerge)
        -[:node]->(importBindingIdentifierToMerge)

DETACH DELETE
    declarationToDelete
	\end{lstlisting}
  \caption{The Cypher query interconnecting the \emph{exportName–importAlias} combination}
  \label{fig:export-import-example-cypher-source}
\end{figure}


\newpage
\section{Simple Analyses by Pattern Matching}

In the Codemodel-Rifle framework, analyses are basically Cypher queries. If a defect's pattern in the Abstract Semantic Graph can be expressed with a Cypher query, it can be detected by the framework. This section details those analyses I implemented for Codemodel-Rifle, which use only pattern matching and do not require to alter the graph.

I developed the analyses by the process I presented in \Cref{section:steps-of-building-new-analyses}. After visualising the defect's pattern with Codemodel-Visualisation, I created the description of the defect by implementing a Cypher query for matching its pattern in the ASG model. The results of the analyses are returned as strings containing defect properties, as described in \Cref{subsection:implementing-analyses}.


\subsection{Uninitialised Variables}

A variable is uninitialised if it was declared but given no value. In most programming languages, uninitialised variables do have \emph{some} value, but it is usually unpredictable \emph{memory garbage} originating from prior values stored at the variable's memory location.

Contrarily in JavaScript, uninitialised variables do not contain random memory garbage. A method or statement evaluating a variable that has not been assigned a value returns \lstinline{undefined}; a primitive value and also a primitive type of JavaScript. Uninitialised variables are of type \lstinline{undefined} with the value \lstinline{undefined}. Per se, uninitialised variables are not defects, but if an uninitialised variable is used without checking whether it is \lstinline{undefined}, it can break code execution in several ways: e.g.\ making the result of the evaluating expression \lstinline{undefined} too, or throwing a \lstinline{ReferenceError}.

\begin{figure}[!htb]
	\centering
	\includegraphics[height=69mm, trim=12mm 12mm 12mm 12mm,clip]{figures/analysis_nonInitializedVariable.pdf}
	\caption{Matching the \lstinline{nonInitialisedVariable} analysis pattern}
	\label{fig:analysis-noninitialisedvariable}
\end{figure}

Regarding uninitialised variables, my analysis in Codemodel-Rifle reports if a variable was not explicitly initialised with an assignment expression.\footnote{The analysis only covers unconditional cases, reporting results of conditional value assignments is currently not supported.} ASG-semantically, this means verifying that the variable's \lstinline{VariableDeclarator} node has no \lstinline{init} relationship. \Cref{fig:analysis-noninitialisedvariable} presents a partial ASG demonstrating how an uninitialised variable is revealed. The nodes with thicker outlines are members of the pattern matching expression, the dashed outlines represent entities being checked for existence. The source code of the analysis is available in the Appendix.


\subsection{Globally Unused Exports}

The \es module system provides a practical solution for keeping code bases organised: logically separated, but practically cooperating software components can be implemented. Exporting only particular entities from a module allows to hide several sensitive information from the outside, such as internal functioning and implementation details, or even security-related specialities. Thus, a best practice is to only export what is explicitly intended to be public, and keep everything else private.

Unused exports can be a security concern. My analysis for detecting unused exports report if an entity is exported, but never imported to any other module. It is based on the semantics of the module interconnections described in \Cref{section:interconnect}.

\Cref{fig:analysis-unusedexport} presents a partial ASG demonstrating how an unused export is revealed. Nodes of the exporter module's graph are indicated with blue colour, nodes of the importer module's graph are indicated with crimson colour. The nodes with thicker outlines are members of the pattern matching expression, the dashed outlines represent entities being checked for existence. The source code of the analysis is available in the Appendix.

\vspace*{1mm}
\begin{figure}[!htb]
	\centering
	\includegraphics[width=\textwidth, trim=12mm 12mm 12mm 12mm,clip]{figures/analysis_exportName.pdf}
	\caption{Matching the \lstinline{unusedExport_exportName} analysis pattern}
	\label{fig:analysis-unusedexport}
\end{figure}


\subsection{Division By Zero (restricted)}

Division by zero is one of the most basic software defects. JavaScript usually does not throw an error if it evaluates such expressions, but returns \lstinline{undefined}, \lstinline{NaN} or \lstinline{Infinity} instead, depending on the environment and the runtime. As stated before, this can break program execution in several ways.

Detecting a division by zero scenario generally is rather challenging by using only static tools. As the right-hand operator of a division expression can be a variable, whose value can be anything — even originate from several other variables —, it needs much more effort than simple pattern matching. Detecting such \emph{transitive} division by zero cases is the subject of the next section, involving the Qualifier System.

However, finding division expressions in the ASG, where the right-hand operator is a numeric literal with the value zero is not complicated. My analysis for this \emph{restricted} case reports such division by zero defects by simple graph pattern matching.

\Cref{fig:analysis-divisionbyzero-simple} presents a partial ASG demonstrating how a division by zero defect is revealed when zero is a numeric literal. The nodes with thicker outlines are members of the pattern matching expression, and the \lstinline{`value'} property of the \lstinline{LiteralNumericExpression} is checked if it equals zero.

\begin{figure}[!htb]
	\centering
	\includegraphics[height=91mm, trim=12mm 12mm 12mm 12mm,clip]{figures/analysis_divisionByZero_simple.pdf}
	\caption{Matching the \lstinline{divisionByZero-literal} analysis pattern}
	\label{fig:analysis-divisionbyzero-simple}
\end{figure}


\subsection{Misuse of Negative Integers as Function Arguments (restricted)}

Generally used functions in JavaScript's \lstinline{Math} library do not support complex numbers. Therefore, if a developer supplies a negative numeric value to a function like \lstinline{Math.sqrt()} or \lstinline{Math.log()}, the expression will return \lstinline{NaN} or \lstinline{undefined}, depending on the environment and the runtime.

My analysis for detecting the misuse of negative integers as function arguments reports if the argument of a \lstinline{log()} or a \lstinline{sqrt()} call is a negative numeric literal.\footnote{This analysis does not cover transitive cases, where the function argument is a variable. That is the subject of the next subsection.}

\begin{figure}[!htb]
	\centering
	\includegraphics[height=90mm, trim=12mm 12mm 12mm 12mm,clip]{figures/analysis_squareRootArgument.pdf}
	\caption{Matching the \lstinline{squareRootNegativeArgument-literal} analysis pattern}
	\label{fig:analysis-squarerootnegativeargument-simple}
\end{figure}

\Cref{fig:analysis-squarerootnegativeargument-simple} presents a partial ASG demonstrating how a square root called with a negative argument defect is revealed when the argument is a numeric literal. The nodes with thicker outlines are members of the pattern matching expression. The \lstinline{`name'} property of the \lstinline{VariableReference} connected to the \lstinline{StaticMemberExpression} is checked whether it is \lstinline{Math}, the \lstinline{`property'} property of the \lstinline{StaticMemberExpression} is checked whether it is \lstinline{sqrt}, and the \lstinline[keywordstyle={}]{`operator'} property of the \lstinline{UnaryExpression} connected to the \lstinline{LiteralNumericExpression} is checked whether it is \lstinline{Minus}. The source code of the analysis is available in the Appendix.


\section{Complex Analyses with the Qualifier System}

Some defects are more general than to present their patterns in an intact graph directly. Detecting complex errors like these may involve to deduce variable and function return values, and it may require to manipulate the graph to dredge defect patterns for matching. Implementing complex analyses for these defects involved the creation of the Qualifier System, a generic graph constraint propagation strategy for revealing — otherwise generally unmatchable — \emph{transitive} defect patterns. This section details the analyses I implemented for Codemodel-Rifle involving extensive graph manipulations, using the Qualifier System.


\subsection{Transitive Defects}

In this thesis, the term transitive defect is used as follows. A software defect is considered \emph{transitive}, if its effect propagates through multiple variable value assignment and/or function calls. Patterns of transitive defects generally can not be directly matched in the ASG, because the graph pattern of such defects — spanning an indeterminate number of functions or variable assignments — can not be described by one general pattern expression. But, patterns of transitive defects can be deduced in the ASG by following their propagation, and marking the intermediate nodes with constraints.

Demonstratively, the running example presented in \Cref{chapter:background} contains a transitive division by zero defect. In the example's \lstinline{exporter} module, there is a variable given the value zero, then the variable is nested into several levels of variable assignments and function return expressions, finally into the \lstinline{exporter} module's default function export. The exported function will return zero, too. After the example's \lstinline{importer} module imports the default export of \lstinline{exporter}, it divides numeric literal $5$ with the return value of the imported function, practically by zero.

The defect is transitive in the meaning that the zero is not a numeric literal $0$ which could be revealed easily by simple pattern matching. Instead, that zero comes from several levels of nested variable assignments and functions — it \emph{transits} along variable assignments and functions. This transitivity can be deduced by the Qualifier System.

\Cref{fig:transitive-defect-propagation} presents the propagation of the running example's transitive division by zero defect in the \lstinline{exporter} module's partial ASG. The graph node marked with black filling is the exported \lstinline{function b()} (which is the right-hand value of the division in the \lstinline{importer} module). The node with crimson filling is the \lstinline{LiteralNumericExpression}, which finally causes \lstinline{function b()} to return 0. The propagation of the transitive defect starts at the assignment of the literal zero (the crimson node), and ends — at least in the \lstinline{exporter} module — at the exported function (the black node). (Of course, the propagation does not end at module boundaries, since the related modules' ASGs are interconnected. In this case however, the \lstinline{importer} module was omitted from the graph for transparency.)

\begin{sidewaysfigure}[!p]
  \centering
	\includegraphics[width=\textwidth, trim=12mm 12mm 12mm 12mm,clip]{figures/transitive-defect-propagation.pdf}
  \caption{The transition path of the running example's division by zero defect}
  \label{fig:transitive-defect-propagation}
\end{sidewaysfigure}


\subsection{Introduction: The Qualifier System}

The Qualifier System is the generalisation of Dániel Stein's Type System~\cite{stein-daniel-msc}. The system assigns well-defined constraints to ASG nodes satisfying certain criteria, then propagates these constraints through the graph by certain rules. These constraints — the \emph{qualifiers} — are \emph{instances} of the Qualifier System: they are represented by graph nodes, connected to a central \lstinline{QualifierSystem} collector node with a \lstinline{:_instance} relationship.

The graph manipulations of the Qualifier System are performed:
\begin{itemize}
\item \textbf{after} the analysed repository is imported/synchronised, the source files' ASGs are constructed, and the related modules' graphs are interconnected to each other,
\item \textbf{before} the defect patterns of the analyses are matched.
\end{itemize}

This allows to first manipulate the graph in several ways by assigning and propagating the qualifiers, and then build pattern matching expressions specifically for the qualifier instances. This way, \emph{transitive} defects — like the running example of \Cref{chapter:background}, where the division by zero is passed along multiple functions and variable assignments — can be detected by deducing the transitions by the qualifiers.

The basic operation of the system is the following. In the enumeration below, the \textbf{phase description} is followed by a concrete demonstrative case based on the running example presented in \Cref{chapter:background}.

\begin{enumerate}
\item \textbf{Initialise the Qualifier System. Create the \lstinline{QualifierSystem} collector node and the qualifier instance nodes.} In the running example, the analysis is based on propagating the \lstinline{EqualsZero} qualifier instance.
\item \textbf{Identify all literals which can be directly marked with a qualifier instance. Connect them to the right qualifier instance with the edge \lstinline{:_qualifier}.} In the running example, it means connecting the \lstinline{LiteralNumericExpression} node of the \lstinline{var a = 0;} variable declaration statement to the \lstinline{EqualsZero} instance.
\item \textbf{Connect adjacent nodes to the same qualifier if they satisfy propagation criteria.} In the running example, it means connecting also the \lstinline{VariableDeclarator} node to the \lstinline{EqualsZero} qualifier instance, because it satisfies the propagation criterion of being connected to a \lstinline{LiteralNumericExpression} by an \lstinline{init} relationship.
\item \textbf{Repeat the previous step until there is no modification in the graph.\footnote{There has to be a stop condition for unintentional infinite loops.}} In the running example — after the propagation finished — the \lstinline{EqualsZero} qualifier will be connected to every entity that is caused to be zero because of the \lstinline{var a = 0;} assignment, including the exported \lstinline{function b()}, and thus the imported \lstinline{defaultName()} function — which is the right-hand side value of the division. Therefore, the transitive division by zero defect can be detected by simply checking whether the right-hand side of the expression has an \lstinline{EqualsZero} qualifier.
\end{enumerate}

If the propagation of the Qualifier System finished, then all transitive defects are \emph{closed} in the meaning that every spread of the defect is marked with a qualifier, so it can be easily detected by a simple pattern matching expression. The following subsections present examples for detecting transitive defects with the Qualifier System.


\subsection{The Running Example's Division By Zero (transitive)}

Detecting a transitive division by zero defect — when the zero expression is not a numeric literal 0, but a variable or a function providing the value zero — requires the right-hand value of the division expression to be deduced. If this value comes from several nested variable assignments and functions, like presented in the running example, the originating value has to be found: a variable assignment with a numeric literal.

Finding a variable assignment, where a numeric literal is the assigned value, can be carried out by simple pattern matching. If this value equals zero, its graph node, the \lstinline{LiteralNumericExpression} is qualified by using an \lstinline{EqualsZero} qualifier instance. After this assignment has been qualified, its adjacent nodes are inspected whether they can be also qualified, according to the propagation rules\footnote{The propagation rules or propagation criteria of Codemodel-Rifle's Qualifier System is implemented as pattern matching queries. Let $N_1$ be qualified by a qualifier instance, and let $N_2$ be an adjacent node of $N_1$ via the relationship $R$. If $R$ is member of the set of qualifier propagator relationships, then $N_2$ gets qualified too.} of the Qualifier System. In the current case, after the \lstinline{LiteralNumericExpression}, its only adjacent ASG node, the \lstinline{VariableDeclaration} gets qualified too by \lstinline{EqualsZero}. This is valid, because the \lstinline{init} edge connecting the two nodes is allowed to propagate an \lstinline{EqualsZero} qualifier instance. After the \lstinline{VariableDeclaration} has been qualified, its adjacent nodes are inspected whether they can be qualified, and the propagation algorithm continues until there are no more paths the qualifier instance could be propagated further on.

In the running example, the propagation of the \lstinline{EqualsZero} qualifier instance stops at the right-hand value of the importer module's division expression. Semantically, the meaning that the right-hand value of the division expression is qualified with an \lstinline{EqualsZero} instance: the division's right-hand side value (the value of the \lstinline{defaultName()} function) has been successfully deduced, and found to be equal to zero.

After the propagation of qualifiers, a simple pattern matching query checks if there are any right-hand values of division expressions qualified by \lstinline{EqualsZero}. If yes, then a division by zero is performed, so it is reported to the developer.

\Cref{fig:divisionbyzero-transitive} presents the propagation of the \lstinline{EqualsZero} qualifier, regarding the running example's transitive division by zero defect. Although the figure is analogous to \Cref{fig:transitive-defect-propagation} by showing the same path, \Cref{fig:transitive-defect-propagation} shows the propagation path of the \emph{defect}, while \Cref{fig:divisionbyzero-transitive} shows the propagation of the \lstinline{EqualsZero} \emph{qualifier}, following the defect.

\begin{sidewaysfigure}[!p]
  \centering
	\includegraphics[width=\textwidth, trim=12mm 12mm 12mm 12mm,clip]{figures/analysis_divisionByZero_transitive.pdf}
  \caption{The propagation path of the \lstinline{EqualsZero} qualifier instance at analysing the running example}
  \label{fig:divisionbyzero-transitive}
\end{sidewaysfigure}


\subsection{Misuse of Negative Integers as Function Arguments (transitive)}

Detecting the misuse of negative function arguments in trasitive cases — when the argument is not a numeric literal, but a variable, whose value can be anything — needs the same value deduction, as detecting a transitive division by zero defect. The difference is the usage of qualifiers: in this case, a \lstinline{NegativeNumeric} qualifier\footnote{The qualifiers' names can be arbitrary, the semantic design of a qualifier-based analysis requires no predefined naming system. The name of a qualifier instance matters only at implementing the pattern matching algorithms for the analyses: e.g.\ an \lstinline{EqualsZero} qualifier is only an error if it is connected to the right-hand side of a division expression.} is utilised instead of an \lstinline{EqualsZero}.

The \lstinline{NegativeNumeric} qualifier is propagated through the graph along the variable assignments and function return expressions, similarly to the \lstinline{EqualsZero}, with the same stop condition. After the propagation of the qualifier, a simple pattern matching query checks if there are any \lstinline{Math.sqrt()} or \lstinline{Math.log()} function calls with their arguments marked as \lstinline{NegativeNumeric}. If yes, then it is a misuse of negative function argument defect, so it is reported to the developer.


\subsection{Unreachable Code caused by Exception (transitive)}

The exception handling of the \es language has the same semantics as Java. If exceptions thrown with the \lstinline{throw} keyword are surrounded by a \lstinline{try..catch} block context, they get caught, and they can be processed or thrown further.

\begin{figure}[!htb]
	\centering
	\begin{lstlisting}[language=JavaScript]
						function throwsException() {
						    return function () {
						        throw new SQLException;
						    };
						}
						let a = throwsException;
						let b = function () {
						    return function () {
						        let c = throwsException();
						        return 42;
						    }
						};
						console.log(b());
						console.log(42);
	\end{lstlisting}
  \caption{Deeply nested exception in \es}
  \label{fig:deeply-nested-exception}
\end{figure}

An exception halts the execution of the program, and yields it to the exception handler — the catch block —, at least if there are handlers implemented by the developer. Source code following an exception throwing statement is not executed, therefore it is unreachable code. Most static analysis tools detect dead code caused by exceptions, but only very shallowly.

\Cref{fig:deeply-nested-exception} presents a program with an exception nested into several levels of functions. The program — instead of logging 42 to the console — will halt, since calling \lstinline{function b()} will eventually cause an \lstinline{SQLException} to be thrown.

By introducing the \lstinline{ExceptionThrown} qualifier instance into the Qualifier System, the propagation path of an exception can be tracked. At analysing the code of \Cref{fig:deeply-nested-exception}, first the \lstinline{throw new SQLException} statement gets marked by the \lstinline{ExceptionThrown} qualifier. Then after several steps of propagation, \lstinline{function b()} also gets marked, therefore it can be easily found by pattern matching. My analysis reports that:

\begin{itemize}
\item an exception is thrown at the execution of the statement \lstinline{console.log(b())}, and
\item because of the exception, the statement \lstinline{console.log(42)} will never be executed.
\end{itemize}


\section{Limitations of the Analyses}

Though the graph-based static analysis approach is a promising novelty from several aspects, my analyses presented in this thesis are very limited in many ways. Implementing \es module interconnections and introducing the Qualifier System were both relevant acts, but they are only supporting elements of the analyses themselves.

Codemodel-Rifle's variable and function value deductions are primitive: no arithmetic operations are supported, the framework tracks only raw, unmodified values. Conditional cases are not covered either: an exception gets detected only if it is unconditionally thrown.

Implementing sound and complete analyses with the Codemodel-Rifle framework is not a subject of this thesis. But — building upon the work of Dániel Stein — the first steps have been made to create a versatile graph-based static analysis tool capable of inspecting enterprise-grade source code repositories coherently.