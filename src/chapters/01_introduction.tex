\chapter{Introduction}


\section{Context}

Software development is a highly complex process involving many people, tools and methods. As the source code repository grows, code quality becomes an important aspect of the development procedure: the software gets more and more complex, the number of human errors in the implementation gets higher and higher. It is important to find and fix these errors as soon as possible: software defects found after deployment are 15 times more costly than if they were found during implementation.~\cite{dawson2010integrating} According to NIST, software bugs cost generally \$59.5 billion for the US government annually.~\cite{tassey2002economic}

Today's developer tools in commercial and open-source projects generally include \emph{version control systems (VCS)} and \emph{continuous integration (CI)} toolsets.~\cite{hilton2016usage, fowlerCI} Integrating code quality assurance tools into the CI platform, or into the developers' \emph{integrated development environment (IDE)}, seems to be the practical choice for enforcing project-/company-wide coding style compliance, and analysing the code deeper whether it contains defects.

A CI tool can be configured to scan and analyse the source code with external tools when the developer commits their code to the central code repository. A common workflow is the following:

\begin{enumerate}
\item the developer edits the code,
\item the developer commits and pushes the modified code into the central repository,
\item the VCS triggers a hook to inform the subscribers of the hook (including the CI platform) that new code has been committed,
\item the CI tool analyses the source code with the static analysis tools integrated and configured by the user, and creates reports about the analyses,
\item the CI tool builds the code with its dependencies and passes on the built artifact for further testing, and finally for deployment.
\end{enumerate}

The reports created by the integrated static analysis tools give the developers insights about code quality and help them discover faults in the software before it gets to testing or production state.

I will focus on the static analysis of JavaScript projects. As JavaScript is an interpreted language, it is generally considered not to require any building to be executed in browsers and external runtimes. Nevertheless, it is sensible to involve CI into JavaScript-projects for code quality and testing purposes, for a so-called transpiling step\footnote{The procedure of transpiling will be detailed in Chapter 2.}, and for automated deployment.


\section{Problem Statement and Requirements}

Despite being the most commonly used programming language in the world~\cite{javascriptstackoverflow}, JavaScript does not have extensive static analysis tooling. There are static analysers for the language, but either their capabilities are very limited, or they require special preparations, like code annotations or special syntax flavours to work appropriately. There are only a couple of general analysers which handle the relations of multiple JavaScript modules.

One solution can be modifying already existing JavaScript-projects according to the needs of the analysis toolsets. If developers annotate their objects and/or use specially extended, non-standard flavours of the JavaScript language, they can get benefits like type inference. For already existing projects being developed for a longer amount of time, this is solution is far from ideal. Since more complex projects can reach 1 million lines of code in size, utilising annotations or special, non-standard syntax flavours would involve huge refactoring costs.

The ideal solution would be a general JavaScript analysis framework with a static type system and other analytical benefits based on nothing else, but the current JavaScript standard\footnote{According to the standard~\cite{ecmascriptstandard}, the official name of the JavaScript language is ECMAScript.}.~\cite{ecmascriptstandard} This ideal solution requires a JavaScript parser complying with the latest {ECMAScript} standards to parse the source files into a data structure that can be processed and manipulated effectively, a database technology for storing the data structure, an intuitive interface to manipulate the data structure for the analyses' purposes, and, necessarily, the analyses' algorithmic descriptions themselves, which reveal the potential defects' location in the software.

The solution can introduce other usability requirements as well, like incremental processing of source code repositories for speed, multi-version data model in accordance with VCSs so the analysis framework can be used by many developers simultaneously, or even a centralized interface for collecting, storing, and presenting previous analysis results for a fine-grained, per-person or per-workgroup efficiency analytics. This thesis focuses on the source code analyses themselves.


\section{Objectives and Contributions}

My prospective colleague and former research fellow, DÃ¡niel Stein created a graph-based static analysis framework for JavaScript (ECMAScript) called \emph{Codemodel-Rifle}.~\cite{stein-daniel-msc} The currently open-sourced project's source code is available on GitHub.~\cite{codemodel-rifle-github} The framework stores the parsed source code repository's each parsed file as a distinct property graph, called an \emph{Abstract Semantic Graph (ASG)}, and gives us an interface to run analyses via graph queries.

My main goal is to extend \emph{Codemodel-Rifle} with several static analysis constraints. This involves providing ways for evaluating analysis queries over multiple JavaScript modules related to each other.

The framework and the analyses are tested with open-source projects and a closed-source, security-oriented industrial project from Tresorit~\cite{tresorit}. The results, if relevant, are delivered to the maintainers of the projects for further evaluation.


\section{Structure of the Thesis}

The thesis is structured as follows. \emph{Chapter 2} presents the conception of static analysis, shortly summarizes the JavaScript and its static analysis approaches to be detailed in Chapter 3, and gives insights to the previously mentioned background technologies of the \emph{Codemodel-Rifle} framework. It also provides an example which will accompany the reader throughout the thesis. \emph{Chapter 3} specifies the currently known approaches and related work. \emph{Chapter 4} gives an overview of my approach of JavaScript static analysis using the \emph{Codemodel-Rifle} framework. \emph{Chapter 5} details the implementation of the analyses and the additional proceedings about processing multiple JavaScript modules related to each other. \emph{Chapter 6} demonstrates and evaluates the implemented analyses. \emph{Chapter 7} provides a case study with a closed-source, security-oriented industrial project from Tresorit. \emph{Chapter 8} concludes the thesis and presents the possible future work.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../main"
%%% End:
