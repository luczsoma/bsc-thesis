\chapter{Introduction}


\section{Context}

Software development is a highly complex process involving many people, tools and methods. As the source code repository grows, code quality becomes an important aspect of the development procedure: the software gets more and more complex, the number of human errors in the implementation gets higher and higher. It is important to find and fix these errors as soon as possible: software defects found after deployment are 15 times more costly than if they were found during implementation.~\cite{dawson2010integrating} According to NIST, software bugs cost generally \$59.5 billion dollars for the US government annually.~\cite{tassey2002economic}

Today's developer tools in commercial or significant open-source projects generally include \emph{version control systems (VCS)} and \emph{continuous integration (CI)} toolsets.~\cite{hilton2016usage}~\cite{fowlerCI} Integrating \emph{code quality assurance} tools into the CI platform (or into the developer's \emph{integrated development environment (IDE)}) seems to be the practical choice for enforcing project-/company-wide coding style compliance, and analysing the code deeper whether it contains defects.

A CI tool can be configured to scan and analyse the source code with external tools when the developer commits their code to the central code repository. A common workflow is the following:

\begin{enumerate}
\item the developer edits the code,
\item the developer commits the modified code into the central repository,
\item the VCS triggers a hook to inform the subscribers of the hook (including the CI platform) that new code has been committed,
\item the CI tool analyses the source code with the static analysis tools integrated and configured by the user, and creates a report about the analyses,
\item the CI tool builds the code with its dependencies and passes on the built artifact for further testing, and finally for deployment.
\end{enumerate}

The reports created by the integrated static analysis tools give the developers insights about code quality and help them discover faults in the software before it gets to testing or production state.

I will focus on the static analysis of JavaScript projects. Although JavaScript is an interpreted language and thus generally considered not to require any building to be executed in browsers, it is still sensible to involve CI into JavaScript-projects for code quality and testing purposes, for a so-called transpiling\footnote{The procedure of transpiling will be detailed in Chapter 2.} step for the sake of compatibility with the language's previous versions, and for automated deployment.


\section{Problem Statement and Requirements}

Despite being the most commonly used programming language in the world~\cite{javascriptstackoverflow}, JavaScript does not have extensive static analysis tooling. There are static analysers for the language, but either their capabilities are very limited, or thy require special preparations, like code annotations or special syntax flavours to work appropriately. There are only a couple of general analysers which handles the relations of multiple JavaScript modules.

One solution can be modifying the existing JavaScript-projects according to the needs of the analysis toolsets. If developers annotate their objects and/or use specially extended, non-standard flavours of the JavaScript language, they can easily get benefits like type inference.

The ideal solution would be a general JavaScript analysis framework with a static type system and other analytical benefits based on nothing else, but the current JavaScript – or more appropriately, ECMAScript – standard.~\cite{ecmascriptstandard} This ideal solution requires a JavaScript parser complying with the latest ECMAScript standards to parse the source files into a data structure that can be processed and manipulated effectively, a database technology for storing the data structure, and an intuitive interface to manipulate the data structure for the analyses' purposes.

The solution can introduce other administrative requirements as well, like incremental processing of source code repositories for speed, multi-threaded functioning in order to be used by many developers simultaneously.


\section{Objectives and Contributions}

My prospective colleague and former mentor, Dániel Stein created a graph-based static analysis framework called \emph{Codemodel-Rifle}.~\cite{stein-daniel-msc} This framework stores the parsed source code repository's each parsed file as a separate property graph – called an \emph{Abstract Syntax Graph} –, and gives us an interface to run analyses via graph queries.

My main goal is to extend \emph{Codemodel-Rifle} with several static analysis constraints. This implies providing ways for evaluating analysis queries involving multiple JavaScript modules related to each other.

The framework and the analyses are tested with open-source projects and a closed-source, security-oriented industrial project from Tresorit~\cite{tresorit}.


\section{Structure of the Thesis}

The thesis is structured as follows. \emph{Chapter 2} presents the conception of static analysis and particularly JavaScript static analysis, and gives insights to the previously mentioned background technologies of the \emph{Codemodel-Rifle} framework. It also provides an example which will accompany the reader throughout the thesis. \emph{Chapter 3} specifies the currently known approaches and related work. \emph{Chapter 4} gives an overview of my approach of JavaScript static analysis using the \emph{Codemodel-Rifle} framework. \emph{Chapter 5} details the implementation of the analyses and the supplementary proceedings about processing multiple JavaScript modules related to each other. \emph{Chapter 6} demonstrates and evaluates the implemented analyses. \emph{Chapter 7} provides a case study with a closed-source, security-oriented industrial project from Tresorit. \emph{Chapter 8} concludes the thesis and presents the possible future work.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../main"
%%% End:
