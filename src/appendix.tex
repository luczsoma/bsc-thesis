\appendix
\chapter*{Appendix}
\phantomsection
\addcontentsline{toc}{chapter}{Appendix}
\renewcommand{\thesection}{\Alph{section}}

\section{Cypher Queries for Interconnecting the ASGs of Related Modules}

\subsection{exportAlias–importAlias}
\begin{lstlisting}[language=Cypher]
MATCH
// exporter.js: export { name1 as exportedName1 };
    (exporter:CompilationUnit)-[:contains]->(:ExportLocals)
        -[:namedExports]->(exportLocalSpecifier:ExportLocalSpecifier)
        -[:name]->(:IdentifierExpression)
        <-[:node]-(:Reference)
        <-[:references]-(:Variable)
        -[:declarations]->(declarationToMerge:Declaration)
        -[:node]->(:BindingIdentifier),

// importer.js: import { exportedName1 as importedName1 } from "exporter";
    (importer:CompilationUnit)-[:contains]->(import:Import)
        -[:namedImports]->(importSpecifier:ImportSpecifier)
        -[:binding]->(importBindingIdentifierToMerge:BindingIdentifier)
        <-[:node]-(declarationToDelete:Declaration)
        <-[:declarations]-(importedVariable:Variable)

    WHERE
    exporter.parsedFilePath CONTAINS import.moduleSpecifier
    AND exportLocalSpecifier.exportedName = importSpecifier.name

MERGE
    (importedVariable)-[:declarations]->(declarationToMerge)
        -[:node]->(importBindingIdentifierToMerge)

DETACH DELETE
    declarationToDelete
\end{lstlisting}


\newpage
\subsection{exportAlias–importDefault}
\begin{lstlisting}[language=Cypher]
MATCH
// exporter.js: export { name1 as default };
    (exporter:CompilationUnit)-[:contains]->(:ExportLocals)
        -[:namedExports]->(exportLocalSpecifier:ExportLocalSpecifier)
        -[:name]->(:IdentifierExpression)
        <-[:node]-(:Reference)
        <-[:references]-(:Variable)
        -[:declarations]->(declarationToMerge:Declaration)
        -[:node]->(:BindingIdentifier),

// importer.js: import defaultName from "exporter";
    (importer:CompilationUnit)-[:contains]->(import:Import)
        -[:defaultBinding]->(importBindingIdentifierToMerge:BindingIdentifier)
        <-[:node]-(declarationToDelete:Declaration)
        <-[:declarations]-(importedVariable:Variable)

    WHERE
    exporter.parsedFilePath CONTAINS import.moduleSpecifier
    AND exportLocalSpecifier.exportedName = 'default'

MERGE
    (importedVariable)-[:declarations]->(declarationToMerge)
        -[:node]->(importBindingIdentifierToMerge)

DETACH DELETE
    declarationToDelete
\end{lstlisting}


\newpage
\subsection{exportAlias–importName}
\begin{lstlisting}[language=Cypher]
MATCH
// exporter.js: export { name1 as exportedName1 };
    (exporter:CompilationUnit)-[:contains]->(:ExportLocals)
        -[:namedExports]->(exportLocalSpecifier:ExportLocalSpecifier)
        -[:name]->(:IdentifierExpression)
        <-[:node]-(:Reference)
        <-[:references]-(:Variable)
        -[:declarations]->(declarationToMerge:Declaration)
        -[:node]->(:BindingIdentifier),

// importer.js: import { exportedName1 } from "exporter";
    (importer:CompilationUnit)-[:contains]->(import:Import)
        -[:namedImports]->(:ImportSpecifier)
        -[:binding]->(importBindingIdentifierToMerge:BindingIdentifier)
        <-[:node]-(declarationToDelete:Declaration)
        <-[:declarations]-(importedVariable:Variable)

    WHERE
    exporter.parsedFilePath CONTAINS import.moduleSpecifier
    AND exportLocalSpecifier.exportedName = importBindingIdentifierToMerge.name

MERGE
    (importedVariable)-[:declarations]->(declarationToMerge)
        -[:node]->(importBindingIdentifierToMerge)

DETACH DELETE
    declarationToDelete
\end{lstlisting}


\newpage
\subsection{exportDeclaration–importAlias}
\begin{lstlisting}[language=Cypher]
MATCH
// exporter.js: export var name1;
    (exporter:CompilationUnit)-[:contains]->(:ExportDeclaration)
        -[:declaration]->
        (:FunctionDeclarationClassDeclarationVariableDeclaration)
        -[:declarators]->(:VariableDeclarator)
        -[:binding]->(exportBindingIdentifier:BindingIdentifier)
        <-[:node]-(declarationToMerge:Declaration)
        <-[:declarations]-(:Variable),

// importer.js: import { name1 as importedName1 } from "exporter";
    (importer:CompilationUnit)-[:contains]->(import:Import)
        -[:namedImports]->(importSpecifier:ImportSpecifier)
        -[:binding]->(importBindingIdentifierToMerge:BindingIdentifier)
        <-[:node]-(declarationToDelete:Declaration)
        <-[:declarations]-(importedVariable:Variable)

    WHERE
    exporter.parsedFilePath CONTAINS import.moduleSpecifier
    AND exportBindingIdentifier.name = importSpecifier.name

MERGE
    (importedVariable)-[:declarations]->(declarationToMerge)
        -[:node]->(importBindingIdentifierToMerge)

DETACH DELETE
    declarationToDelete
\end{lstlisting}


\newpage
\subsection{exportDeclaration–importName}
\begin{lstlisting}[language=Cypher]
MATCH
// exporter.js: export var name1;
    (exporter:CompilationUnit)-[:contains]->(:ExportDeclaration)
        -[:declaration]->
        (:FunctionDeclarationClassDeclarationVariableDeclaration)
        -[:declarators]->(:VariableDeclarator)
        -[:binding]->(exportBindingIdentifier:BindingIdentifier)
        <-[:node]-(declarationToMerge:Declaration)
        <-[:declarations]-(:Variable),

// importer.js: import { name1 } from "exporter";
    (importer:CompilationUnit)-[:contains]->(import:Import)
        -[:namedImports]->(importSpecifier:ImportSpecifier)
        -[:binding]->(importBindingIdentifierToMerge:BindingIdentifier)
        <-[:node]-(declarationToDelete:Declaration)
        <-[:declarations]-(importedVariable:Variable)

    WHERE
    exporter.parsedFilePath CONTAINS import.moduleSpecifier
    AND exportBindingIdentifier.name = importBindingIdentifierToMerge.name

MERGE
    (importedVariable)-[:declarations]->(declarationToMerge)
        -[:node]->(importBindingIdentifierToMerge)

DETACH DELETE
    declarationToDelete
\end{lstlisting}


\newpage
\subsection{exportDefaultDeclaration–importAlias}
\begin{lstlisting}[language=Cypher]
MATCH
// exporter.js: export default name1;
    (exporter:CompilationUnit)-[:contains]->(:ExportDefault)
        -[:body]->(:FunctionDeclarationClassDeclarationVariableDeclaration)
        -[:name]->(exportBindingIdentifier:BindingIdentifier)
        <-[:node]-(declarationToMerge:Declaration)
        <-[:declarations]-(exportedVariable:Variable),

// importer.js: import { name1 as importedName1 } from "exporter";
    (importer:CompilationUnit)-[:contains]->(import:Import)
        -[:namedImports]->(importSpecifier:ImportSpecifier)
        -[:binding]->(importBindingIdentifierToMerge:BindingIdentifier)
        <-[:node]-(declarationToDelete:Declaration)
        <-[:declarations]-(importedVariable:Variable)

    WHERE
    exporter.parsedFilePath CONTAINS import.moduleSpecifier
    AND importSpecifier.name = exportBindingIdentifier.name

MERGE
    (importedVariable)-[:declarations]->(declarationToMerge)
        -[:node]->(importBindingIdentifierToMerge)

DETACH DELETE
    declarationToDelete
\end{lstlisting}


\newpage
\subsection{exportDefaultDeclaration–importDefault}
\begin{lstlisting}[language=Cypher]
MATCH
// exporter.js: export default name1;
    (exporter:CompilationUnit)-[:contains]->(:ExportDefault)
        -[:body]->(:FunctionDeclarationClassDeclarationVariableDeclaration)
        -[:name]->(exportBindingIdentifier:BindingIdentifier)
        <-[:node]-(declarationToMerge:Declaration)
        <-[:declarations]-(exportedVariable:Variable),

// importer.js: import defaultName from "exporter";
    (importer:CompilationUnit)-[:contains]->(import:Import)
        -[:defaultBinding]->(importBindingIdentifierToMerge:BindingIdentifier)
        <-[:node]-(declarationToDelete:Declaration)
        <-[:declarations]-(importedVariable:Variable)

    WHERE
    exporter.parsedFilePath CONTAINS import.moduleSpecifier

MERGE
    (importedVariable)-[:declarations]->(declarationToMerge)
        -[:node]->(importBindingIdentifierToMerge)

DETACH DELETE
    declarationToDelete
\end{lstlisting}


\newpage
\subsection{exportDefaultDeclaration–importName}
\begin{lstlisting}[language=Cypher]
MATCH
// exporter.js: export default name1;
    (exporter:CompilationUnit)-[:contains]->(:ExportDefault)
        -[:body]->(:FunctionDeclarationClassDeclarationVariableDeclaration)
        -[:name]->(exportBindingIdentifier:BindingIdentifier)
        <-[:node]-(declarationToMerge:Declaration)
        <-[:declarations]-(exportedVariable:Variable),

// importer.js: import { name1 } from "exporter";
    (importer:CompilationUnit)-[:contains]->(import:Import)
        -[:namedImports]->(importSpecifier:ImportSpecifier)
        -[:binding]->(importBindingIdentifierToMerge:BindingIdentifier)
        <-[:node]-(declarationToDelete:Declaration)
        <-[:declarations]-(importedVariable:Variable)

    WHERE
    exporter.parsedFilePath CONTAINS import.moduleSpecifier
    AND importBindingIdentifierToMerge.name = exportBindingIdentifier.name

MERGE
    (importedVariable)-[:declarations]->(declarationToMerge)
        -[:node]->(importBindingIdentifierToMerge)

DETACH DELETE
    declarationToDelete
\end{lstlisting}


\newpage
\subsection{exportDefaultName–importAlias}
\begin{lstlisting}[language=Cypher]
MATCH
// exporter.js: export default name1;
    (exporter:CompilationUnit)-[:contains]->(:ExportDefault)
        -[:body]->(exportedIdentifierExpression:IdentifierExpression)
        <-[:node]-(:Reference)
        <-[:references]-(exportedVariable:Variable)
        -[:declarations]->(declarationToMerge:Declaration),

// importer.js: import { name1 as importedName1 } from "exporter";
    (importer:CompilationUnit)-[:contains]->(import:Import)
        -[:namedImports]->(importSpecifier:ImportSpecifier)
        -[:binding]->(importBindingIdentifierToMerge:BindingIdentifier)
        <-[:node]-(declarationToDelete:Declaration)
        <-[:declarations]-(importedVariable:Variable)

    WHERE
    exporter.parsedFilePath CONTAINS import.moduleSpecifier
    AND exportedIdentifierExpression.name = importSpecifier.name

MERGE
    (importedVariable)-[:declarations]->(declarationToMerge)
        -[:node]->(importBindingIdentifierToMerge)

DETACH DELETE
    declarationToDelete
\end{lstlisting}


\newpage
\subsection{exportDefaultName–importDefault}
\begin{lstlisting}[language=Cypher]
MATCH
// exporter.js: export default name1;
    (exporter:CompilationUnit)-[:contains]->(:ExportDefault)
        -[:body]->(exportedIdentifierExpression:IdentifierExpression)
        <-[:node]-(:Reference)
        <-[:references]-(exportedVariable:Variable)
        -[:declarations]->(declarationToMerge:Declaration),

// importer.js: import defaultName from "exporter";
    (importer:CompilationUnit)-[:contains]->(import:Import)
        -[:defaultBinding]->(importBindingIdentifierToMerge:BindingIdentifier)
        <-[:node]-(declarationToDelete:Declaration)
        <-[:declarations]-(importedVariable:Variable)

    WHERE
    exporter.parsedFilePath CONTAINS import.moduleSpecifier

MERGE
    (importedVariable)-[:declarations]->(declarationToMerge)
        -[:node]->(importBindingIdentifierToMerge)

DETACH DELETE
    declarationToDelete
\end{lstlisting}


\newpage
\subsection{exportDefaultName–importName}
\begin{lstlisting}[language=Cypher]
MATCH
// exporter.js: export default name1;
    (exporter:CompilationUnit)-[:contains]->(:ExportDefault)
        -[:body]->(exportedIdentifierExpression:IdentifierExpression)
        <-[:node]-(:Reference)
        <-[:references]-(exportedVariable:Variable)
        -[:declarations]->(declarationToMerge:Declaration),

// importer.js: import { name1 } from "exporter";
    (importer:CompilationUnit)-[:contains]->(import:Import)
        -[:namedImports]->(importSpecifier:ImportSpecifier)
        -[:binding]->(importBindingIdentifierToMerge:BindingIdentifier)
        <-[:node]-(declarationToDelete:Declaration)
        <-[:declarations]-(importedVariable:Variable)

    WHERE
    exporter.parsedFilePath CONTAINS import.moduleSpecifier
    AND exportedIdentifierExpression.name = importBindingIdentifierToMerge.name

MERGE
    (importedVariable)-[:declarations]->(declarationToMerge)
        -[:node]->(importBindingIdentifierToMerge)

DETACH DELETE
    declarationToDelete
\end{lstlisting}


\newpage
\subsection{exportName–importAlias}
\begin{lstlisting}[language=Cypher]
MATCH
// exporter.js: let name1 = "name1Value"; export { name1 };
    (exporter:CompilationUnit)-[:contains]->(:ExportLocals)
        -[:namedExports]->(:ExportLocalSpecifier)
        -[:name]->(exportBindingIdentifier:IdentifierExpression)
        <-[:node]-(:Reference)<-[:references]-(:Variable)
        -[:declarations]->(declarationToMerge:Declaration)
        -[:node]->(:BindingIdentifier),

// importer.js: import { name1 as importedName1 } from "exporter";
    (importer:CompilationUnit)-[:contains]->(import:Import)
        -[:namedImports]->(importSpecifier:ImportSpecifier)
        -[:binding]->(importBindingIdentifierToMerge:BindingIdentifier)
        <-[:node]-(declarationToDelete:Declaration)
        <-[:declarations]-(importedVariable:Variable)

    WHERE
    exporter.parsedFilePath CONTAINS import.moduleSpecifier
    AND exportBindingIdentifier.name = importSpecifier.name

MERGE
    (importedVariable)-[:declarations]->(declarationToMerge)
        -[:node]->(importBindingIdentifierToMerge)

DETACH DELETE
    declarationToDelete
\end{lstlisting}


\newpage
\subsection{exportName–importName}
\begin{lstlisting}[language=Cypher]
MATCH
// exporter.js: export { name1 };
    (exporter:CompilationUnit)-[:contains]->(:ExportLocals)
        -[:namedExports]->(exportLocalSpecifier:ExportLocalSpecifier)
        -[:name]->(exportBindingIdentifier:IdentifierExpression)
        <-[:node]-(:Reference)
        <-[:references]-(:Variable)
        -[:declarations]->(declarationToMerge:Declaration)
        -[:node]->(:BindingIdentifier),

// importer.js: import { name1 } from "exporter";
    (importer:CompilationUnit)-[:contains]->(import:Import)
        -[:namedImports]->(importSpecifier:ImportSpecifier)
        -[:binding]->(importBindingIdentifierToMerge:BindingIdentifier)
        <-[:node]-(declarationToDelete:Declaration)
        <-[:declarations]-(importedVariable:Variable)

    WHERE
    exporter.parsedFilePath CONTAINS import.moduleSpecifier
    AND exportBindingIdentifier.name = importBindingIdentifierToMerge.name
    AND NOT exists(exportLocalSpecifier.exportedName)
    AND NOT exists(importSpecifier.name)

MERGE
    (importedVariable)-[:declarations]->(declarationToMerge)
        -[:node]->(importBindingIdentifierToMerge)

DETACH DELETE
    declarationToDelete
\end{lstlisting}


\newpage
\section{Cypher Queries of the Analyses}

\subsection{nonInitialisedVariable}
\begin{lstlisting}[language=Cypher]
MATCH
    (containingCompilationUnit:CompilationUnit)-[:contains]->
        (variableLocation:SourceLocation)<-[:start]-(:SourceSpan)
        <-[:location]-(variableReference:VariableReference)
        <-[:node]-(:Reference)
        <-[:references]-(subjectVariable:Variable)
        -[:declarations]->(:Declaration)
        -[:node]->(:VariableReference)
        <-[:binding]-(variableDeclarator:VariableDeclarator)

    WHERE NOT (variableDeclarator)-[:init]->()

RETURN
    'Non-initialized variable' AS message,
    subjectVariable.name AS entityName,
    containingCompilationUnit.parsedFilePath AS compilationUnitPath,
    variableLocation.line AS line,
    variableLocation.column AS column
\end{lstlisting}


\newpage
\subsection{unusedExport — exportName-exportAlias}
\begin{lstlisting}[language=Cypher]
MATCH
    (exporter:CompilationUnit)-[:contains]->(:ExportLocals)
        -[:namedExports]->(exportLocalSpecifier:ExportLocalSpecifier)
        -[:name]->(:VariableReference)
        <-[:node]-(:Reference)
        <-[:references]-(exportedVariable:Variable),
    (exportLocalSpecifier)-[:location]->(:SourceSpan)
        -[:start]->(exportLocation:SourceLocation)

    WHERE
    NOT (exportedVariable)-[:declarations]->(:Declaration)
        -[:node]->(:VariableReference)
        <-[:binding]-(:ImportSpecifier)

RETURN
    'Globally unused export' AS message,
    exportedVariable.name AS entityName,
    exporter.parsedFilePath AS compilationUnitPath,
    exportLocation.line AS line,
    exportLocation.column AS column
\end{lstlisting}


\newpage
\subsection{unusedExport — exportDefault-exportDefaultName}
\begin{lstlisting}[language=Cypher]
MATCH
    (exporter:CompilationUnit)-[:contains]->(exportDefault:ExportDefault)
        -[:body]->(:IdentifierExpression)
        <-[:node]-(:Reference)
        <-[:references]-(exportedVariable:Variable),
    (exportDefault)-[:location]->(:SourceSpan)
        -[:start]->(exportLocation:SourceLocation),

    (exporter:CompilationUnit)-[:contains]->(:ExportLocals)
        -[:namedExports]->(exportLocalSpecifier:ExportLocalSpecifier)
        -[:name]->(:VariableReference)
        <-[:node]-(:Reference)
        <-[:references]-(exportedVariable:Variable),
    (exportLocalSpecifier)-[:location]->(:SourceSpan)
        -[:start]->(exportLocation:SourceLocation)

    WHERE
    NOT (exportedVariable)-[:declarations]->(:Declaration)
        -[:node]->(:VariableReference)
        <-[:binding]-(:ImportSpecifier)

RETURN
    'Globally unused export' AS message,
    exportedVariable.name AS entityName,
    exporter.parsedFilePath AS compilationUnitPath,
    exportLocation.line AS line,
    exportLocation.column AS column
\end{lstlisting}


\newpage
\subsection{unusedExport — exportDeclaration}
\begin{lstlisting}[language=Cypher]
MATCH
    (exporter:CompilationUnit)-[:contains]->
        (exportDeclaration:ExportDeclaration)
        -[:declaration]->
        (:FunctionDeclarationClassDeclarationVariableDeclaration)
        -[*1..2]->(:BindingIdentifier)
        <-[:node]-(:Declaration)
        <-[:declarations]-(exportedVariable:Variable),
    (exportDeclaration)-[:location]->(:SourceSpan)
        -[:start]->(exportLocation:SourceLocation)

    WHERE
    NOT (exportedVariable)-[:declarations]->(:Declaration)
        -[:node]->(:VariableReference)
        <-[:binding]-(:ImportSpecifier)

RETURN
    'Globally unused export' AS message,
    exportedVariable.name AS entityName,
    exporter.parsedFilePath AS compilationUnitPath,
    exportLocation.line AS line,
    exportLocation.column AS column
\end{lstlisting}


\newpage
\subsection{divisionByZero-literal — restricted}
\begin{lstlisting}[language=Cypher]
MATCH
    (binaryExpression:BinaryExpression)-[:right]->
        (rightValue:LiteralNumericExpression)
        -[:location]->(:SourceSpan)
        -[:start]->(locationStart:SourceLocation)
        <-[:contains]-(containingCompilationUnit:CompilationUnit)

    WHERE
    binaryExpression.operator = 'Div'
    AND rightValue.value = 0

RETURN
    'Division by zero' AS message,
    '' AS entityName,
    containingCompilationUnit.parsedFilePath AS compilationUnitPath,
    locationStart.line AS line,
    locationStart.column AS column
\end{lstlisting}


\newpage
\subsection{squareRootNegativeArgument-literal — restricted}
\begin{lstlisting}[language=Cypher]
MATCH
    (containingCompilationUnit:CompilationUnit)-[:contains]->
        (callExpression:CallExpression)
        -[:callee]->(memberExpression:StaticMemberExpression)
        -[:object]->(variableReference:VariableReference),
    (callExpression)-[:arguments]->(unaryExpression:UnaryExpression)
        -[:operand]->(:LiteralNumericExpression),
    (callExpression)-[:location]->
         (:SourceSpan)-[:start]->(entityLocation:SourceLocation)

    WHERE
    variableReference.name = 'Math'
    AND memberExpression.property = 'sqrt'
    AND unaryExpression.operator = 'Minus'

RETURN
    'Square root called with negative argument' AS message,
    '' AS entityName,
    containingCompilationUnit.parsedFilePath AS compilationUnitPath,
    entityLocation.line AS line,
    entityLocation.column AS column
\end{lstlisting}


\newpage
\subsection{divisionByZero-variable — transitive}
\begin{lstlisting}[language=Cypher]
MATCH
    (binaryExpression:BinaryExpression)-[:right]->(rightValue:Expression)
        -[:location]->(:SourceSpan)
        -[:start]->(locationStart:SourceLocation)
        <-[:contains]-(containingCompilationUnit:CompilationUnit),
    (rightValue)-[:_qualifier]->(equalsZero:EqualsZero)

    WHERE
    binaryExpression.operator = 'Div'

RETURN
    'Division by zero' AS message,
    '' AS entityName,
    containingCompilationUnit.parsedFilePath AS compilationUnitPath,
    locationStart.line AS line,
    locationStart.column AS column
\end{lstlisting}


\newpage
\subsection{squareRootNegativeArgument-variable — transitive}
\begin{lstlisting}[language=Cypher]
MATCH
    (containingCompilationUnit:CompilationUnit)-[:contains]->
        (callExpression:CallExpression)
        -[:callee]->(memberExpression:StaticMemberExpression)
        -[:object]->(variableReference:VariableReference),
    (callExpression)-[:arguments]->(argument:Expression)
        -[:_qualifier]->(negativeNumeric:NegativeNumeric),
    (callExpression)-[:location]->
         (:SourceSpan)-[:start]->(entityLocation:SourceLocation)

    WHERE
    variableReference.name = 'Math'
    AND memberExpression.property = 'sqrt'

RETURN
    'Square root called with negative argument' AS message,
    '' AS entityName,
    containingCompilationUnit.parsedFilePath AS compilationUnitPath,
    entityLocation.line AS line,
    entityLocation.column AS column
\end{lstlisting}


\newpage
\subsection{unreachableCode-exception — transitive}
\begin{lstlisting}[language=Cypher]
MATCH
    (containingCompilationUnit:CompilationUnit)-[:contains]->
        (statement:Statement)-[:_qualifier]->(:ExceptionThrown),
    (statement)-[:_next]->(unreachableStatement:Statement),
    (unreachableStatement)-[:location]->(:SourceSpan)
        -[:start]->(entityLocation:SourceLocation)

RETURN
    'Unreachable code' AS message,
    '' AS entityName,
    containingCompilationUnit.parsedFilePath AS compilationUnitPath,
    entityLocation.line AS line,
    entityLocation.column AS column
\end{lstlisting}


\newpage
\section{Cypher Queries of the Qualifier System}

\subsection{Initialising the Qualifier System Initialisation}
\begin{lstlisting}[language=Cypher]
MERGE (qs:QualifierSystem)

MERGE (qs)-[:_instance]->(:Qualifier:EqualsZero)
MERGE (qs)-[:_instance]->(:Qualifier:NegativeNumeric)
MERGE (qs)-[:_instance]->(:Qualifier:ExceptionThrown)
\end{lstlisting}


\subsection[Tagging the literals with EqualsZero]{Tagging the literals with \lstinline{EqualsZero}}
\begin{lstlisting}[language=Cypher]
MATCH
    (literalNumericExpression:LiteralNumericExpression),
    (qs:QualifierSystem)-[:_instance]->(equalsZero:Qualifier:EqualsZero)

    WHERE
    literalNumericExpression.value = 0

MERGE
    (literalNumericExpression)-[:_qualifier]->(equalsZero)
\end{lstlisting}


\subsection[Tagging the exception throw statements with ExceptionThrown]{Tagging the exception throw statements with \lstinline{ExceptionThrown}}
\begin{lstlisting}[language=Cypher]
MATCH
    (throwStatement:ThrowStatement),
    (qs:QualifierSystem)-[:_instance]->(exceptionThrown:ExceptionThrown)

MERGE
    (throwStatement)-[:_qualifier]->(exceptionThrown)
\end{lstlisting}


\newpage
\section{Cypher Queries for Qualifier Propagation}

\subsection{Propagation along function calls}
\begin{lstlisting}[language=Cypher]
MATCH
    (callExpression:CallExpression)-[:callee]->(:Expression)
        -[:_qualifier]->(qualifier:Qualifier)

MERGE
    (callExpression)-[:_qualifier]->(qualifier)
\end{lstlisting}


\subsection{Propagation along function declarations}
\begin{lstlisting}[language=Cypher]
MATCH
    (qualifier:Qualifier)<-[:_qualifier]-(functionDeclaration:FunctionDeclaration)
        -[:name]->(bindingIdentifier:BindingIdentifier)

MERGE
    (bindingIdentifier)-[:_qualifier]->(qualifier)
\end{lstlisting}


\subsection{Propagation along function return statements}
\begin{lstlisting}[language=Cypher]
MATCH
    (function:Function)-[:body]->(:FunctionBody)
        -[:statements]->(:ReturnStatement)
        -[:expression]->(:Expression)
        -[:_qualifier]->(qualifier:Qualifier)

MERGE
    (function)-[:_qualifier]->(qualifier)
\end{lstlisting}


\subsection{Propagation along throw statements in functions}
\begin{lstlisting}[language=Cypher]
MATCH
    (function:Function)-[:body]->(:FunctionBody)
        -[:statements]->(:ThrowStatement)
        -[:_qualifier]->(qualifier:Qualifier)

MERGE
    (function)-[:_qualifier]->(qualifier)
\end{lstlisting}


\newpage
\subsection{Propagation along variable declarations}
\begin{lstlisting}[language=Cypher]
MATCH
    (variable:Variable)-[:declarations]->(:Declaration)
        -[:node]->(:BindingIdentifier)
        -[:_qualifier]->(qualifier:Qualifier)

MERGE
    (variable)-[:_qualifier]->(qualifier)
\end{lstlisting}


\subsection{Propagation along variable declaration statements}
\begin{lstlisting}[language=Cypher]
MATCH
    (variableDeclarationStatement:VariableDeclarationStatement)
        -[:declaration]->(variableDeclaration:VariableDeclaration)
        -[:declarators]->(variableDeclarator:VariableDeclarator)
        -[:binding]->(:BindingIdentifier)-[:_qualifier]->(qualifier:Qualifier)

MERGE
    (variableDeclarationStatement)-[:_qualifier]->(qualifier)
MERGE
    (variableDeclaration)-[:_qualifier]->(qualifier)
MERGE
    (variableDeclaration)-[:_qualifier]->(qualifier)
\end{lstlisting}


\subsection{Propagation along variable initialisations}
\begin{lstlisting}[language=Cypher]
MATCH
    (expression:Expression)-[:_qualifier]->(qualifier:Qualifier),
    (expression)<-[:init]-(:VariableDeclarator)-[:binding]
        ->(:BindingIdentifier)<-[:node]-(:Reference)
        <-[:references]-(variable:Variable)

MERGE
    (variable)-[:_qualifier]->(qualifier)
\end{lstlisting}


\subsection{Propagation along variable references}
\begin{lstlisting}[language=Cypher]
MATCH
    (variable:Variable)-[:_qualifier]->(qualifier:Qualifier),
    (variable)-[:references]->(:Reference)
        -[:node]->(variableReference:VariableReference)

MERGE
    (variableReference)-[:_qualifier]->(qualifier)
\end{lstlisting}