\appendix
\chapter*{Appendix}
\phantomsection
\addcontentsline{toc}{chapter}{Appendix}
\renewcommand{\thesection}{\Alph{section}}

\section{Cypher Queries for Interconnecting the ASGs of Related Modules}

\subsection{exportAlias–importAlias}
\begin{lstlisting}[language=Cypher]
MATCH
// exporter.js: export { name1 as exportedName1 };
    (exporter:CompilationUnit)-[:contains]->(:ExportLocals)
        -[:namedExports]->(exportLocalSpecifier:ExportLocalSpecifier)
        -[:name]->(:IdentifierExpression)
        <-[:node]-(:Reference)
        <-[:references]-(:Variable)
        -[:declarations]->(declarationToMerge:Declaration)
        -[:node]->(:BindingIdentifier),

// importer.js: import { exportedName1 as importedName1 } from "exporter";
    (importer:CompilationUnit)-[:contains]->(import:Import)
        -[:namedImports]->(importSpecifier:ImportSpecifier)
        -[:binding]->(importBindingIdentifierToMerge:BindingIdentifier)
        <-[:node]-(declarationToDelete:Declaration)
        <-[:declarations]-(importedVariable:Variable)

    WHERE
    exporter.parsedFilePath CONTAINS import.moduleSpecifier
    AND exportLocalSpecifier.exportedName = importSpecifier.name

MERGE
    (importedVariable)-[:declarations]->(declarationToMerge)
        -[:node]->(importBindingIdentifierToMerge)

DETACH DELETE
    declarationToDelete
\end{lstlisting}

\newpage
\subsection{exportAlias–importDefault}
\begin{lstlisting}[language=Cypher]
MATCH
// exporter.js: export { name1 as default };
    (exporter:CompilationUnit)-[:contains]->(:ExportLocals)
        -[:namedExports]->(exportLocalSpecifier:ExportLocalSpecifier)
        -[:name]->(:IdentifierExpression)
        <-[:node]-(:Reference)
        <-[:references]-(:Variable)
        -[:declarations]->(declarationToMerge:Declaration)
        -[:node]->(:BindingIdentifier),

// importer.js: import defaultName from "exporter";
    (importer:CompilationUnit)-[:contains]->(import:Import)
        -[:defaultBinding]->(importBindingIdentifierToMerge:BindingIdentifier)
        <-[:node]-(declarationToDelete:Declaration)
        <-[:declarations]-(importedVariable:Variable)

    WHERE
    exporter.parsedFilePath CONTAINS import.moduleSpecifier
    AND exportLocalSpecifier.exportedName = 'default'

MERGE
    (importedVariable)-[:declarations]->(declarationToMerge)
        -[:node]->(importBindingIdentifierToMerge)

DETACH DELETE
    declarationToDelete
\end{lstlisting}

\newpage
\subsection{exportAlias–importName}
\begin{lstlisting}[language=Cypher]
MATCH
// exporter.js: export { name1 as exportedName1 };
    (exporter:CompilationUnit)-[:contains]->(:ExportLocals)
        -[:namedExports]->(exportLocalSpecifier:ExportLocalSpecifier)
        -[:name]->(:IdentifierExpression)
        <-[:node]-(:Reference)
        <-[:references]-(:Variable)
        -[:declarations]->(declarationToMerge:Declaration)
        -[:node]->(:BindingIdentifier),

// importer.js: import { exportedName1 } from "exporter";
    (importer:CompilationUnit)-[:contains]->(import:Import)
        -[:namedImports]->(:ImportSpecifier)
        -[:binding]->(importBindingIdentifierToMerge:BindingIdentifier)
        <-[:node]-(declarationToDelete:Declaration)
        <-[:declarations]-(importedVariable:Variable)

    WHERE
    exporter.parsedFilePath CONTAINS import.moduleSpecifier
    AND exportLocalSpecifier.exportedName = importBindingIdentifierToMerge.name

MERGE
    (importedVariable)-[:declarations]->(declarationToMerge)
        -[:node]->(importBindingIdentifierToMerge)

DETACH DELETE
    declarationToDelete
\end{lstlisting}

\newpage
\subsection{exportDeclaration–importAlias}
\begin{lstlisting}[language=Cypher]
MATCH
// exporter.js: export var name1;
    (exporter:CompilationUnit)-[:contains]->(:ExportDeclaration)
        -[:declaration]->
        (:FunctionDeclarationClassDeclarationVariableDeclaration)
        -[:declarators]->(:VariableDeclarator)
        -[:binding]->(exportBindingIdentifier:BindingIdentifier)
        <-[:node]-(declarationToMerge:Declaration)
        <-[:declarations]-(:Variable),

// importer.js: import { name1 as importedName1 } from "exporter";
    (importer:CompilationUnit)-[:contains]->(import:Import)
        -[:namedImports]->(importSpecifier:ImportSpecifier)
        -[:binding]->(importBindingIdentifierToMerge:BindingIdentifier)
        <-[:node]-(declarationToDelete:Declaration)
        <-[:declarations]-(importedVariable:Variable)

    WHERE
    exporter.parsedFilePath CONTAINS import.moduleSpecifier
    AND exportBindingIdentifier.name = importSpecifier.name

MERGE
    (importedVariable)-[:declarations]->(declarationToMerge)
        -[:node]->(importBindingIdentifierToMerge)

DETACH DELETE
    declarationToDelete
\end{lstlisting}

\newpage
\subsection{exportDeclaration–importName}
\begin{lstlisting}[language=Cypher]
MATCH
// exporter.js: export var name1;
    (exporter:CompilationUnit)-[:contains]->(:ExportDeclaration)
        -[:declaration]->
        (:FunctionDeclarationClassDeclarationVariableDeclaration)
        -[:declarators]->(:VariableDeclarator)
        -[:binding]->(exportBindingIdentifier:BindingIdentifier)
        <-[:node]-(declarationToMerge:Declaration)
        <-[:declarations]-(:Variable),

// importer.js: import { name1 } from "exporter";
    (importer:CompilationUnit)-[:contains]->(import:Import)
        -[:namedImports]->(importSpecifier:ImportSpecifier)
        -[:binding]->(importBindingIdentifierToMerge:BindingIdentifier)
        <-[:node]-(declarationToDelete:Declaration)
        <-[:declarations]-(importedVariable:Variable)

    WHERE
    exporter.parsedFilePath CONTAINS import.moduleSpecifier
    AND exportBindingIdentifier.name = importBindingIdentifierToMerge.name

MERGE
    (importedVariable)-[:declarations]->(declarationToMerge)
        -[:node]->(importBindingIdentifierToMerge)

DETACH DELETE
    declarationToDelete
\end{lstlisting}

\newpage
\subsection{exportDefaultDeclaration–importAlias}
\begin{lstlisting}[language=Cypher]
MATCH
// exporter.js: export default name1;
    (exporter:CompilationUnit)-[:contains]->(:ExportDefault)
        -[:body]->(:FunctionDeclarationClassDeclarationVariableDeclaration)
        -[:name]->(exportBindingIdentifier:BindingIdentifier)
        <-[:node]-(declarationToMerge:Declaration)
        <-[:declarations]-(exportedVariable:Variable),

// importer.js: import { name1 as importedName1 } from "exporter";
    (importer:CompilationUnit)-[:contains]->(import:Import)
        -[:namedImports]->(importSpecifier:ImportSpecifier)
        -[:binding]->(importBindingIdentifierToMerge:BindingIdentifier)
        <-[:node]-(declarationToDelete:Declaration)
        <-[:declarations]-(importedVariable:Variable)

    WHERE
    exporter.parsedFilePath CONTAINS import.moduleSpecifier
    AND importSpecifier.name = exportBindingIdentifier.name

MERGE
    (importedVariable)-[:declarations]->(declarationToMerge)
        -[:node]->(importBindingIdentifierToMerge)

DETACH DELETE
    declarationToDelete
\end{lstlisting}

\newpage
\subsection{exportDefaultDeclaration–importDefault}
\begin{lstlisting}[language=Cypher]
MATCH
// exporter.js: export default name1;
    (exporter:CompilationUnit)-[:contains]->(:ExportDefault)
        -[:body]->(:FunctionDeclarationClassDeclarationVariableDeclaration)
        -[:name]->(exportBindingIdentifier:BindingIdentifier)
        <-[:node]-(declarationToMerge:Declaration)
        <-[:declarations]-(exportedVariable:Variable),

// importer.js: import defaultName from "exporter";
    (importer:CompilationUnit)-[:contains]->(import:Import)
        -[:defaultBinding]->(importBindingIdentifierToMerge:BindingIdentifier)
        <-[:node]-(declarationToDelete:Declaration)
        <-[:declarations]-(importedVariable:Variable)

    WHERE
    exporter.parsedFilePath CONTAINS import.moduleSpecifier

MERGE
    (importedVariable)-[:declarations]->(declarationToMerge)
        -[:node]->(importBindingIdentifierToMerge)

DETACH DELETE
    declarationToDelete
\end{lstlisting}

\newpage
\subsection{exportDefaultDeclaration–importName}
\begin{lstlisting}[language=Cypher]
MATCH
// exporter.js: export default name1;
    (exporter:CompilationUnit)-[:contains]->(:ExportDefault)
        -[:body]->(:FunctionDeclarationClassDeclarationVariableDeclaration)
        -[:name]->(exportBindingIdentifier:BindingIdentifier)
        <-[:node]-(declarationToMerge:Declaration)
        <-[:declarations]-(exportedVariable:Variable),

// importer.js: import { name1 } from "exporter";
    (importer:CompilationUnit)-[:contains]->(import:Import)
        -[:namedImports]->(importSpecifier:ImportSpecifier)
        -[:binding]->(importBindingIdentifierToMerge:BindingIdentifier)
        <-[:node]-(declarationToDelete:Declaration)
        <-[:declarations]-(importedVariable:Variable)

    WHERE
    exporter.parsedFilePath CONTAINS import.moduleSpecifier
    AND importBindingIdentifierToMerge.name = exportBindingIdentifier.name

MERGE
    (importedVariable)-[:declarations]->(declarationToMerge)
        -[:node]->(importBindingIdentifierToMerge)

DETACH DELETE
    declarationToDelete
\end{lstlisting}

\newpage
\subsection{exportDefaultName–importAlias}
\begin{lstlisting}[language=Cypher]
MATCH
// exporter.js: export default name1;
    (exporter:CompilationUnit)-[:contains]->(:ExportDefault)
        -[:body]->(exportedIdentifierExpression:IdentifierExpression)
        <-[:node]-(:Reference)
        <-[:references]-(exportedVariable:Variable)
        -[:declarations]->(declarationToMerge:Declaration),

// importer.js: import { name1 as importedName1 } from "exporter";
    (importer:CompilationUnit)-[:contains]->(import:Import)
        -[:namedImports]->(importSpecifier:ImportSpecifier)
        -[:binding]->(importBindingIdentifierToMerge:BindingIdentifier)
        <-[:node]-(declarationToDelete:Declaration)
        <-[:declarations]-(importedVariable:Variable)

    WHERE
    exporter.parsedFilePath CONTAINS import.moduleSpecifier
    AND exportedIdentifierExpression.name = importSpecifier.name

MERGE
    (importedVariable)-[:declarations]->(declarationToMerge)
        -[:node]->(importBindingIdentifierToMerge)

DETACH DELETE
    declarationToDelete
\end{lstlisting}

\newpage
\subsection{exportDefaultName–importDefault}
\begin{lstlisting}[language=Cypher]
MATCH
// exporter.js: export default name1;
    (exporter:CompilationUnit)-[:contains]->(:ExportDefault)
        -[:body]->(exportedIdentifierExpression:IdentifierExpression)
        <-[:node]-(:Reference)
        <-[:references]-(exportedVariable:Variable)
        -[:declarations]->(declarationToMerge:Declaration),

// importer.js: import defaultName from "exporter";
    (importer:CompilationUnit)-[:contains]->(import:Import)
        -[:defaultBinding]->(importBindingIdentifierToMerge:BindingIdentifier)
        <-[:node]-(declarationToDelete:Declaration)
        <-[:declarations]-(importedVariable:Variable)

    WHERE
    exporter.parsedFilePath CONTAINS import.moduleSpecifier

MERGE
    (importedVariable)-[:declarations]->(declarationToMerge)
        -[:node]->(importBindingIdentifierToMerge)

DETACH DELETE
    declarationToDelete
\end{lstlisting}

\newpage
\subsection{exportDefaultName–importName}
\begin{lstlisting}[language=Cypher]
MATCH
// exporter.js: export default name1;
    (exporter:CompilationUnit)-[:contains]->(:ExportDefault)
        -[:body]->(exportedIdentifierExpression:IdentifierExpression)
        <-[:node]-(:Reference)
        <-[:references]-(exportedVariable:Variable)
        -[:declarations]->(declarationToMerge:Declaration),

// importer.js: import { name1 } from "exporter";
    (importer:CompilationUnit)-[:contains]->(import:Import)
        -[:namedImports]->(importSpecifier:ImportSpecifier)
        -[:binding]->(importBindingIdentifierToMerge:BindingIdentifier)
        <-[:node]-(declarationToDelete:Declaration)
        <-[:declarations]-(importedVariable:Variable)

    WHERE
    exporter.parsedFilePath CONTAINS import.moduleSpecifier
    AND exportedIdentifierExpression.name = importBindingIdentifierToMerge.name

MERGE
    (importedVariable)-[:declarations]->(declarationToMerge)
        -[:node]->(importBindingIdentifierToMerge)

DETACH DELETE
    declarationToDelete
\end{lstlisting}

\newpage
\subsection{exportName–importAlias}
\begin{lstlisting}[language=Cypher]
MATCH
// exporter.js: let name1 = "name1Value"; export { name1 };
    (exporter:CompilationUnit)-[:contains]->(:ExportLocals)
        -[:namedExports]->(:ExportLocalSpecifier)
        -[:name]->(exportBindingIdentifier:IdentifierExpression)
        <-[:node]-(:Reference)<-[:references]-(:Variable)
        -[:declarations]->(declarationToMerge:Declaration)
        -[:node]->(:BindingIdentifier),

// importer.js: import { name1 as importedName1 } from "exporter";
    (importer:CompilationUnit)-[:contains]->(import:Import)
        -[:namedImports]->(importSpecifier:ImportSpecifier)
        -[:binding]->(importBindingIdentifierToMerge:BindingIdentifier)
        <-[:node]-(declarationToDelete:Declaration)
        <-[:declarations]-(importedVariable:Variable)

    WHERE
    exporter.parsedFilePath CONTAINS import.moduleSpecifier
    AND exportBindingIdentifier.name = importSpecifier.name

MERGE
    (importedVariable)-[:declarations]->(declarationToMerge)
        -[:node]->(importBindingIdentifierToMerge)

DETACH DELETE
    declarationToDelete
\end{lstlisting}

\newpage
\subsection{exportName–importName}
\begin{lstlisting}[language=Cypher]
MATCH
// exporter.js: export { name1 };
    (exporter:CompilationUnit)-[:contains]->(:ExportLocals)
        -[:namedExports]->(exportLocalSpecifier:ExportLocalSpecifier)
        -[:name]->(exportBindingIdentifier:IdentifierExpression)
        <-[:node]-(:Reference)
        <-[:references]-(:Variable)
        -[:declarations]->(declarationToMerge:Declaration)
        -[:node]->(:BindingIdentifier),

// importer.js: import { name1 } from "exporter";
    (importer:CompilationUnit)-[:contains]->(import:Import)
        -[:namedImports]->(importSpecifier:ImportSpecifier)
        -[:binding]->(importBindingIdentifierToMerge:BindingIdentifier)
        <-[:node]-(declarationToDelete:Declaration)
        <-[:declarations]-(importedVariable:Variable)

    WHERE
    exporter.parsedFilePath CONTAINS import.moduleSpecifier
    AND exportBindingIdentifier.name = importBindingIdentifierToMerge.name
    AND NOT exists(exportLocalSpecifier.exportedName)
    AND NOT exists(importSpecifier.name)

MERGE
    (importedVariable)-[:declarations]->(declarationToMerge)
        -[:node]->(importBindingIdentifierToMerge)

DETACH DELETE
    declarationToDelete
\end{lstlisting}


\newpage
\section{Cypher Queries of the Analyses}

\subsection{nonInitialisedVariable}
\begin{lstlisting}[language=Cypher]
MATCH
    (containingCompilationUnit:CompilationUnit)-[:contains]->
        (variableLocation:SourceLocation)<-[:start]-(:SourceSpan)
        <-[:location]-(variableReference:VariableReference)
        <-[:node]-(:Reference)
        <-[:references]-(subjectVariable:Variable)
        -[:declarations]->(:Declaration)
        -[:node]->(:VariableReference)
        <-[:binding]-(variableDeclarator:VariableDeclarator)

    WHERE NOT (variableDeclarator)-[:init]->()

RETURN
    'Non-initialized variable' AS message,
    subjectVariable.name AS entityName,
    containingCompilationUnit.parsedFilePath AS compilationUnitPath,
    variableLocation.line AS line,
    variableLocation.column AS column
\end{lstlisting}

\newpage
\subsection{unusedExport — exportName-exportAlias}
\begin{lstlisting}[language=Cypher]
MATCH
    (exporter:CompilationUnit)-[:contains]->(:ExportLocals)
        -[:namedExports]->(exportLocalSpecifier:ExportLocalSpecifier)
        -[:name]->(:VariableReference)
        <-[:node]-(:Reference)
        <-[:references]-(exportedVariable:Variable),
    (exportLocalSpecifier)-[:location]->(:SourceSpan)
        -[:start]->(exportLocation:SourceLocation)

    WHERE
    NOT (exportedVariable)-[:declarations]->(:Declaration)
        -[:node]->(:VariableReference)
        <-[:binding]-(:ImportSpecifier)

RETURN
    'Globally unused export' AS message,
    exportedVariable.name AS entityName,
    exporter.parsedFilePath AS compilationUnitPath,
    exportLocation.line AS line,
    exportLocation.column AS column
\end{lstlisting}

\newpage
\subsection{unusedExport — exportDefault-exportDefaultName}
\begin{lstlisting}[language=Cypher]
MATCH
    (exporter:CompilationUnit)-[:contains]->(exportDefault:ExportDefault)
        -[:body]->(:IdentifierExpression)
        <-[:node]-(:Reference)
        <-[:references]-(exportedVariable:Variable),
    (exportDefault)-[:location]->(:SourceSpan)
        -[:start]->(exportLocation:SourceLocation),

    (exporter:CompilationUnit)-[:contains]->(:ExportLocals)
        -[:namedExports]->(exportLocalSpecifier:ExportLocalSpecifier)
        -[:name]->(:VariableReference)
        <-[:node]-(:Reference)
        <-[:references]-(exportedVariable:Variable),
    (exportLocalSpecifier)-[:location]->(:SourceSpan)
        -[:start]->(exportLocation:SourceLocation)

    WHERE
    NOT (exportedVariable)-[:declarations]->(:Declaration)
        -[:node]->(:VariableReference)
        <-[:binding]-(:ImportSpecifier)

RETURN
    'Globally unused export' AS message,
    exportedVariable.name AS entityName,
    exporter.parsedFilePath AS compilationUnitPath,
    exportLocation.line AS line,
    exportLocation.column AS column
\end{lstlisting}

\newpage
\subsection{unusedExport — exportDeclaration}
\begin{lstlisting}[language=Cypher]
MATCH
    (exporter:CompilationUnit)-[:contains]->
        (exportDeclaration:ExportDeclaration)
        -[:declaration]->
        (:FunctionDeclarationClassDeclarationVariableDeclaration)
        -[*1..2]->(:BindingIdentifier)
        <-[:node]-(:Declaration)
        <-[:declarations]-(exportedVariable:Variable),
    (exportDeclaration)-[:location]->(:SourceSpan)
        -[:start]->(exportLocation:SourceLocation)

    WHERE
    NOT (exportedVariable)-[:declarations]->(:Declaration)
        -[:node]->(:VariableReference)
        <-[:binding]-(:ImportSpecifier)

RETURN
    'Globally unused export' AS message,
    exportedVariable.name AS entityName,
    exporter.parsedFilePath AS compilationUnitPath,
    exportLocation.line AS line,
    exportLocation.column AS column
\end{lstlisting}

\newpage
\subsection{divisionByZero-literal — restricted}
\begin{lstlisting}[language=Cypher]
MATCH
    (binaryExpression:BinaryExpression)-[:right]->
        (rightValue:LiteralNumericExpression)
        -[:location]->(:SourceSpan)
        -[:start]->(locationStart:SourceLocation)
        <-[:contains]-(containingCompilationUnit:CompilationUnit)

    WHERE
    binaryExpression.operator = 'Div'
    AND rightValue.value = 0

RETURN
    'Division by zero' AS message,
    '' AS entityName,
    containingCompilationUnit.parsedFilePath AS compilationUnitPath,
    locationStart.line AS line,
    locationStart.column AS column
\end{lstlisting}

\newpage
\subsection{squareRootNegativeArgument-literal — restricted}
\begin{lstlisting}[language=Cypher]
MATCH
    (containingCompilationUnit:CompilationUnit)-[:contains]->
        (callExpression:CallExpression)
        -[:callee]->(memberExpression:StaticMemberExpression)
        -[:object]->(variableReference:VariableReference),
    (callExpression)-[:arguments]->(unaryExpression:UnaryExpression)
        -[:operand]->(:LiteralNumericExpression),
    (callExpression)-[:location]->
         (:SourceSpan)-[:start]->(entityLocation:SourceLocation)

    WHERE
    variableReference.name = 'Math'
    AND memberExpression.property = 'sqrt'
    AND unaryExpression.operator = 'Minus'

RETURN
    'Square root called with negative argument' AS message,
    '' AS entityName,
    containingCompilationUnit.parsedFilePath AS compilationUnitPath,
    entityLocation.line AS line,
    entityLocation.column AS column
\end{lstlisting}